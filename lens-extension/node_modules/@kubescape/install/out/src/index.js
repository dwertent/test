"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KubescapeApi = exports.install = exports.isWindows = void 0;
const os = __importStar(require("os"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const cp = __importStar(require("child_process"));
const stream = __importStar(require("stream"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const compare_versions_1 = __importDefault(require("compare-versions"));
const util_1 = require("util");
const TXT_LATEST = "latest";
const PACKAGE_BASE_URL = "https://api.github.com/repos/armosec/kubescape/releases/latest";
const PACKAGE_DOWNLOAD_BASE_URL = "https://github.com/armosec/kubescape/releases/download";
const COMMAND_SCAN_CONTEXT = "--kube-context";
const COMMAND_SCAN = "scan";
const COMMAND_LIST_FRAMEWORKS = "list frameworks";
const COMMAND_DOWNLOAD_FRAMEWORK = "download framework";
const COMMAND_DOWNLOAD_ARTIFACTS = "download artifacts";
const COMMAND_GET_VERSION = "version";
const COMMAND_GET_HELP = "help";
const ERROR_KUBESCAPE_NOT_INSTALLED = "Kubescape is not installed!";
const ENV_SKIP_UPDATE_CHECK = "KUBESCAPE_SKIP_UPDATE_CHECK";
const MAX_SCAN_BUFFER = 100 * 1024 * 1024;
const extractBetween = (str, surround) => {
    return str.substring(str.indexOf(surround) + 1, str.lastIndexOf(surround));
};
const toJsonArray = (str) => {
    let obj;
    try {
        obj = JSON.parse(str);
        if (!Array.isArray(obj)) {
            obj = [obj];
        }
    }
    catch (e) {
        console.error(e);
        obj = [];
    }
    return obj;
};
const toJson = (str) => {
    let obj;
    try {
        obj = JSON.parse(str);
    }
    catch (_a) {
        obj = {};
    }
    return obj;
};
class KubescapeVersion {
    constructor(version = "unknown", latest = true) {
        this.version = version;
        this.isLatest = latest;
    }
}
function expand(str) {
    let expandedPath = path.normalize(str);
    if (expandedPath.length <= 0)
        return expandedPath;
    if (expandedPath[0] === '~') {
        expandedPath = path.join(os.homedir(), expandedPath.slice(1));
    }
    for (let env of Object.keys(process.env)) {
        const to = process.env[env];
        const from = "$" + env;
        if (!to)
            continue;
        expandedPath = expandedPath.replace(from, to);
    }
    return expandedPath;
}
/**
 * Download a file to the system
 * @param url download address
 * @param downloadDir target directory on the system
 * @param fileName save the download with this filename
 * @param abort an option to abort the process
 * @param ui an external set os graphic fronts for displaying information
 * @param executable is the file needs to be executable
 * @returns the full path of the downloaded file
 */
function downloadFile(url, downloadDir, fileName, abort, ui, executable = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const decodedTargetDir = decodeURIComponent(downloadDir);
        let localPath = path.resolve(decodedTargetDir, fileName);
        try {
            yield ui.progress("Downloading Kubescape", abort, (progress) => __awaiter(this, void 0, void 0, function* () {
                let opts = {};
                if (abort) {
                    opts.signal = abort.signal;
                }
                ui.debug(`Attempt to download kubescape into '${localPath}'`);
                ui.debug(`creating ${downloadDir}`);
                yield fs.promises.mkdir(decodedTargetDir, { recursive: true });
                const response = yield (0, node_fetch_1.default)(url, opts);
                if (!response.ok || !response.body) {
                    ui.error(`Failed to download ${url}`);
                    throw new Error;
                }
                ui.debug(`Requesting kubescape status: ${response.statusText} (${response.status})`);
                const size = Number(response.headers.get('content-length'));
                let read = 0;
                response.body.on('data', (chunk) => {
                    read += chunk.length;
                    progress(read / size);
                });
                const out = fs.createWriteStream(localPath);
                yield (0, util_1.promisify)(stream.pipeline)(response.body, out).catch(e => {
                    fs.unlink(localPath, (_) => null);
                    throw e;
                });
                if (executable) {
                    yield fs.promises.chmod(localPath, fs.constants.S_IRWXU | fs.constants.S_IRWXG | fs.constants.S_IXOTH);
                }
                ui.info(`Successfully downloaded ${fileName} into ${downloadDir}`);
            }));
        }
        catch (e) {
            ui.error(`Could not download ${url}, reason: ${e}`);
            localPath = "";
        }
        finally {
            return localPath;
        }
    });
}
/**
 * Get the right asset name for each OS
 * @returns The right asset name depended on the system
 */
function chooseKubescapeAsset() {
    const variants = {
        "linux": "kubescape-ubuntu-latest",
        "darwin": "kubescape-macos-latest",
        "win32": "kubescape-windows-latest"
    };
    return variants[os.platform()];
}
function isWindows() {
    return process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
}
exports.isWindows = isWindows;
/**
 * Finds the right latest version we have
 */
function getLatestVersionUrl() {
    return __awaiter(this, void 0, void 0, function* () {
        let res = yield (0, node_fetch_1.default)(PACKAGE_BASE_URL);
        let obj = yield res.json();
        return obj.html_url.replace("/tag/", "/download/");
    });
}
/**
 * Get the latest version available
 * @returns latest version tag name
 */
function getLatestVersion() {
    return __awaiter(this, void 0, void 0, function* () {
        let res = yield (0, node_fetch_1.default)(PACKAGE_BASE_URL);
        let obj = yield res.json();
        return obj.tag_name;
    });
}
/**
 * Install kubescape binary on the system
 * @param kubescapeDir Which directory should kubescape be located at
 * @param ui A set of UI fronts to display information graphically
 * @returns true on success
 */
function install(version, kubescapeDir, ui, cancel = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
        /* set download url */
        let binaryUrl;
        if (version === TXT_LATEST) {
            binaryUrl = yield getLatestVersionUrl();
        }
        else {
            binaryUrl = `${PACKAGE_DOWNLOAD_BASE_URL}/${version}`;
        }
        binaryUrl += `/${chooseKubescapeAsset()}`;
        const kubescapeName = getOsKubescapeFilename();
        const kubescapeFullPath = yield downloadFile(binaryUrl, kubescapeDir, kubescapeName, cancel, ui, !isWindows());
        if (kubescapeFullPath.length > 0) {
            return true;
        }
        return false;
    });
}
exports.install = install;
function appendToFrameworks(to, from) {
    for (let framework of from) {
        const key = framework.name;
        if (to && !to[key]) {
            to[key] = framework;
        }
    }
}
function resolveKubescapeFramework(frameworkOutput) {
    const parts = frameworkOutput.split(':');
    const frameworkName = extractBetween(parts[1], "'");
    const frameworkPath = extractBetween(parts[2], "'");
    return {
        name: frameworkName.toLocaleLowerCase(),
        location: frameworkPath,
        isInstalled: false
    };
}
function resolveKubescapeFrameworks(frameworkOutputs) {
    return frameworkOutputs.map(frameworkOutput => resolveKubescapeFramework(frameworkOutput));
}
function getOsKubescapeFilename() {
    const platform = os.platform();
    return "kubescape" + (platform == "win32" ? ".exe" : "");
}
function getKubescapePath(basedir) {
    const decodedBaedir = path.resolve(decodeURIComponent(basedir));
    return {
        baseDir: decodedBaedir,
        fullPath: path.join(expand(decodedBaedir), getOsKubescapeFilename()),
    };
}
function isKubescapeInstalled(kubescapePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            cp.exec(`"${kubescapePath}" ${COMMAND_GET_HELP}`, err => {
                /* broken binary */
                if (err) {
                    console.error(err);
                    return resolve(false);
                }
                return resolve(true);
            });
        });
    });
}
class KubescapeApi {
    constructor() {
        this._isInitialized = false;
        this._isInstalled = false;
        this._path = undefined;
        this._versionInfo = undefined;
        this._frameworks = undefined;
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new KubescapeApi;
        }
        return this._instance;
    }
    get isInstalled() {
        return this._isInstalled;
    }
    get path() {
        if (!this._path) {
            throw new Error(ERROR_KUBESCAPE_NOT_INSTALLED);
        }
        return this._path.fullPath;
    }
    get directory() {
        if (!this._path.baseDir) {
            throw new Error(ERROR_KUBESCAPE_NOT_INSTALLED);
        }
        return this._path.baseDir;
    }
    get version() {
        if (!this._versionInfo) {
            throw new Error(ERROR_KUBESCAPE_NOT_INSTALLED);
        }
        return this._versionInfo.version;
    }
    get isLatestVersion() {
        if (!this._versionInfo) {
            console.log(this._versionInfo);
            throw new Error(ERROR_KUBESCAPE_NOT_INSTALLED);
        }
        return this._versionInfo.isLatest;
    }
    get frameworkDirectory() {
        if (!this._frameworkDir) {
            throw new Error(ERROR_KUBESCAPE_NOT_INSTALLED);
        }
        return this._frameworkDir;
    }
    get frameworksNames() {
        /* check if already cached */
        if (this._frameworks) {
            return Object.keys(this._frameworks).reduce((filtered, frameworkName) => {
                if (this._frameworks[frameworkName].isInstalled) {
                    filtered.push(frameworkName);
                }
                return filtered;
            }, []);
        }
        return [];
    }
    get frameworks() {
        /* check if already cached */
        if (this._frameworks) {
            return Object.keys(this._frameworks).map(frameworkName => this._frameworks[frameworkName]);
        }
        return [];
    }
    _buildKubescapeCommand(command, kubeconfigPath) {
        let kubescapeCommand = `"${this.path}" ${command}`;
        if (kubeconfigPath != null) {
            if (isWindows()) {
                kubescapeCommand = `set "KUBECONFIG=${kubeconfigPath}" & ${kubescapeCommand}`;
            }
            else {
                kubescapeCommand = `KUBECONFIG="${kubeconfigPath}" ${kubescapeCommand}`;
            }
        }
        return kubescapeCommand;
    }
    getKubescapeVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isInstalled) {
                throw new Error(ERROR_KUBESCAPE_NOT_INSTALLED);
            }
            const env = {};
            env[ENV_SKIP_UPDATE_CHECK] = "1";
            const cmd = this._buildKubescapeCommand(COMMAND_GET_VERSION);
            let verInfo = new KubescapeVersion;
            return new Promise(resolve => {
                cp.exec(cmd, { env: env }, (err, stdout, stderr) => __awaiter(this, void 0, void 0, function* () {
                    if (err) {
                        throw Error(stderr);
                    }
                    const verRegex = /v\d+\.\d+\.\d+/g;
                    let match = stdout.match(verRegex);
                    if (match) {
                        verInfo.version = match[0];
                        const latestVersion = yield getLatestVersion();
                        verInfo.isLatest = latestVersion === verInfo.version;
                    }
                    resolve(verInfo);
                }));
            });
        });
    }
    downloadMissingFrameworks(requiredFrameworks, ui) {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = requiredFrameworks.map(framework => new Promise((resolve, reject) => {
                const cmd = this._buildKubescapeCommand(`${COMMAND_DOWNLOAD_FRAMEWORK} ${framework} -o "${this.frameworkDirectory}"`);
                ui.debug(`downloading missing frameworks. Command: ${cmd}`);
                cp.exec(cmd, (err, stdout, stderr) => {
                    ui.debug(`stdout: ${stdout}, stderr: ${stderr}`);
                    if (err) {
                        reject(`Could not download framework ${framework}. Reason:\n${stderr}`);
                    }
                    if ((0, compare_versions_1.default)(this.version, "v2.0.150") >= 0) {
                        const info = toJson(stderr);
                        resolve({
                            name: info.name.toLocaleLowerCase(),
                            location: info.path,
                            isInstalled: false
                        });
                    }
                    else {
                        /* match download artifacts command output */
                        const res = stdout.replace("'framework'", `'framework': '${framework}'`);
                        resolve(resolveKubescapeFramework(res));
                    }
                });
            }));
            return Promise.all(promises);
        });
    }
    downloadAllFrameworks(ui) {
        return __awaiter(this, void 0, void 0, function* () {
            /* download all */
            const cmd = this._buildKubescapeCommand(`${COMMAND_DOWNLOAD_ARTIFACTS} --output "${this.frameworkDirectory}"`);
            ui.debug(`downloading all frameworks. Command: ${cmd}`);
            return new Promise(resolve => {
                cp.exec(cmd, (err, stdout, stderr) => {
                    var _a;
                    ui.debug(`stdout: ${stdout}, stderr: ${stderr}, version: ${this.version}`);
                    if (err) {
                        throw new Error(`Unable to download artifacts:\n${stderr}`);
                    }
                    const stdoutLineRegex = /\'framework'.+/g;
                    if ((0, compare_versions_1.default)(this.version, "v2.0.150") >= 0 || !stdout.match(stdoutLineRegex)) {
                        let ksFrameworks = [];
                        const output = stderr.split("\n");
                        output.forEach(line => {
                            const info = toJson(line);
                            if (info.artifact == "framework") {
                                ksFrameworks.push({
                                    name: info.name.toLocaleLowerCase(),
                                    location: info.path,
                                    isInstalled: false
                                });
                            }
                        });
                        resolve(ksFrameworks);
                    }
                    else {
                        let results = [];
                        (_a = stdout.match(stdoutLineRegex)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
                            results.push(e);
                        });
                        const ksFrameworks = resolveKubescapeFrameworks(results);
                        resolve(ksFrameworks);
                    }
                });
            });
        });
    }
    /**
     * Get locally installed framework files
     * @returns A list of installed framework files
     */
    getInstalledFrameworks() {
        return __awaiter(this, void 0, void 0, function* () {
            let files = yield fs.promises.readdir(this.frameworkDirectory);
            let frameworkFiles = yield new Promise(resolve => {
                resolve(files.filter(file => {
                    if (file.endsWith('.json')) {
                        try {
                            const f_text = fs.readFileSync(decodeURIComponent(path.join(this.frameworkDirectory, file)), "utf8");
                            const obj = toJson(f_text);
                            if (obj['controls']) {
                                return true;
                            }
                            return false;
                        }
                        catch (_a) {
                            return false;
                        }
                    }
                    return false;
                }));
            });
            return frameworkFiles.map(frameworkFile => {
                return {
                    name: frameworkFile.split('.')[0].toLocaleLowerCase(),
                    isInstalled: false,
                    location: expand(path.join(this.frameworkDirectory, frameworkFile))
                };
            });
        });
    }
    /**
     * Get backend available, yet uninstalled framework files
     * @returns A list of available framework files
     */
    getUninstalledFramework() {
        return __awaiter(this, void 0, void 0, function* () {
            const cmd = this._buildKubescapeCommand(COMMAND_LIST_FRAMEWORKS);
            return new Promise(resolve => {
                cp.exec(cmd, (err, stdout, stderr) => {
                    var _a;
                    let result = [];
                    if (err) {
                        /* on error return empty but don't define in cache */
                        throw new Error(stderr);
                    }
                    // const lineRegex = new RegExp(/\* .+\n/)
                    const lineRegex = /\* .+\n/g;
                    (_a = stdout.match(lineRegex)) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
                        result.push(element.replace("* ", "").trimEnd());
                    });
                    resolve(result.filter(framework => {
                        return !this._frameworks[framework.toLocaleLowerCase()];
                    }));
                });
            });
        });
    }
    /**
     * Install frameworks from backend locally
     * @param frameworks A list of desired frameworks to install
     * @param ui Swiss army tools for ui handling
     */
    installFrameworks(frameworks, ui) {
        return __awaiter(this, void 0, void 0, function* () {
            let frameworksNeedsDownload = [];
            for (let framework of frameworks) {
                if (this._frameworks && this._frameworks[framework]) {
                    this._frameworks[framework].isInstalled = true;
                }
                else {
                    frameworksNeedsDownload.push(framework);
                }
            }
            if (frameworksNeedsDownload.length > 0) {
                const newInstalledFrameworks = yield this.downloadMissingFrameworks(frameworksNeedsDownload, ui);
                ui.debug(`New frameworks downloaded: ${newInstalledFrameworks}`);
                appendToFrameworks(this._frameworks, newInstalledFrameworks);
            }
        });
    }
    /**
     * Scan yaml files using Kubescape
     * @param ui Swiss army tools for ui handling
     * @param filePath The file path to scan
     * @returns JSON object with the results of the scan
     */
    scanYaml(ui, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const useArtifactsFrom = `--use-artifacts-from "${this.frameworkDirectory}"`;
            const scanFrameworks = this.frameworksNames.join(",");
            const cmd = this._buildKubescapeCommand(`${COMMAND_SCAN} ${useArtifactsFrom} framework ${scanFrameworks} "${path.resolve(filePath)}" --format json`);
            return yield ui.slow("Kubescape scanning", () => __awaiter(this, void 0, void 0, function* () {
                return new Promise(resolve => {
                    cp.exec(cmd, (err, stdout, stderr) => __awaiter(this, void 0, void 0, function* () {
                        if (err) {
                            ui.error(stderr);
                            resolve({});
                            return;
                        }
                        const res = toJsonArray(stdout);
                        if (!res) {
                            resolve({});
                            return;
                        }
                        resolve(res);
                    }));
                });
            }));
        });
    }
    /**
     * Scan yaml files using Kubescape
     * @param ui Swiss army tools for ui handling
     * @param context The cluster context to use for scanning
     * @returns JSON object with the results of the scan
     */
    scanCluster(ui, context, kubeconfigPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const useArtifactsFrom = `--use-artifacts-from "${this.frameworkDirectory}"`;
            const scanFrameworks = this.frameworksNames.join(",");
            const cmd = this._buildKubescapeCommand(`${COMMAND_SCAN} ${useArtifactsFrom} framework ${scanFrameworks} ${COMMAND_SCAN_CONTEXT} ${context} --format json`, kubeconfigPath);
            ui.debug(`running kubescape scan command: ${cmd}`);
            return yield ui.slow(`Kubescape scanning cluster ${context}`, () => __awaiter(this, void 0, void 0, function* () {
                return new Promise(resolve => {
                    cp.exec(cmd, { maxBuffer: MAX_SCAN_BUFFER }, (err, stdout, stderr) => __awaiter(this, void 0, void 0, function* () {
                        ui.debug(`stdout: ${stdout}, stderr: ${stderr}`);
                        if (err) {
                            ui.error(stderr);
                        }
                        const res = toJsonArray(stdout);
                        if (!res || res.length <= 0) {
                            ui.error(`not valid response was given. stdout: ${stdout}, stderr: ${stderr}`);
                            return resolve({});
                        }
                        return resolve(res);
                    }));
                });
            }));
        });
    }
    /**
     * Setup and initialize kubescape
     * @param ui Swiss army tools for ui handling
     * @param configs Kubescape configuration to respect
     * @returns True, on successful installs
     */
    setup(ui, configs, abort = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            return ui.progress("Initializing kubescape", null, (progress) => __awaiter(this, void 0, void 0, function* () {
                /* initialize only once */
                if (this._isInitialized)
                    return true;
                const tasksCount = 5;
                let completedTasks = 0;
                /* 1. Get kubescape path */
                /* ---------------------------------------------------------------*/
                this._path = getKubescapePath(configs.baseDirectory);
                completedTasks++;
                progress(completedTasks / tasksCount);
                ui.debug(`Kubescape will be used from ${this.path}`);
                /* 2. Check installation state */
                /* ---------------------------------------------------------------*/
                this._isInstalled = yield isKubescapeInstalled(this.path);
                ui.debug(`Kubescape install status: ${this._isInstalled ? "installed" : "missing"}`);
                let needsUpdate = !this.isInstalled;
                completedTasks++;
                progress(completedTasks / tasksCount);
                /* 3. Query config to choose between version tiers */
                /* ---------------------------------------------------------------*/
                ui.debug(`Kubescape requested version: ${configs.version}`);
                if (!needsUpdate) {
                    /* kubescape exists - check version match */
                    this._versionInfo = yield this.getKubescapeVersion();
                    if (configs.version !== this.version) {
                        if (configs.version === TXT_LATEST) {
                            const latestVersionTag = yield getLatestVersion();
                            needsUpdate = latestVersionTag !== this.version;
                        }
                        else {
                            needsUpdate = true;
                        }
                    }
                }
                completedTasks++;
                progress(completedTasks / tasksCount);
                /* 4. Install kubescape if needed */
                /* ---------------------------------------------------------------*/
                if (needsUpdate) {
                    ui.debug(`Kubescape needs to be updated to version: ${configs.version}`);
                    this._isInstalled = yield install(configs.version, this.directory, ui, abort);
                    if (!this.isInstalled) {
                        ui.error(ERROR_KUBESCAPE_NOT_INSTALLED);
                        abort.abort();
                        return false;
                    }
                    /* Get version again after update */
                    this._versionInfo = yield this.getKubescapeVersion();
                }
                completedTasks++;
                progress(completedTasks / tasksCount);
                ui.debug(`Using Kubescape version: ${this.version}`);
                /* Set version if not already set */
                if (!this._versionInfo) {
                    this._versionInfo = new KubescapeVersion(configs.version, false);
                }
                /* 5. Initialize frameworks */
                /* ---------------------------------------------------------------*/
                this._frameworks = {};
                this._frameworkDir = decodeURIComponent(expand(path.resolve(configs.frameworksDirectory)));
                if (this._frameworkDir && this._frameworkDir.length > 0) {
                    /* Get custom frameworks from specified directories */
                    try {
                        yield fs.promises.mkdir(this._frameworkDir, { recursive: true });
                        yield fs.promises.access(this._frameworkDir);
                    }
                    catch (_a) {
                        /* Fallback to kubescape directory */
                        ui.info(`Cannot access ${this._frameworkDir}. Using fallback instead.`);
                        this._frameworkDir = this.directory;
                    }
                }
                else {
                    /* Get available frameworks from kubescape directory */
                    this._frameworkDir = this.directory;
                }
                appendToFrameworks(this._frameworks, yield this.getInstalledFrameworks());
                /* Get required frameworks */
                let requiredFrameworks = configs.requiredFrameworks;
                if (requiredFrameworks && !requiredFrameworks.includes('all')) {
                    /* Download only required frameworks (filter out availables) */
                    ui.debug("Requiring specific frameworks");
                    requiredFrameworks = requiredFrameworks.filter(framework => {
                        return !this._frameworks[framework];
                    });
                    if (requiredFrameworks.length > 0) {
                        yield this.installFrameworks(requiredFrameworks, ui);
                    }
                }
                else {
                    /* Download all artifacts including all frameworks */
                    ui.debug("Requiring all the available frameworks");
                    const allFrameworks = yield this.downloadAllFrameworks(ui);
                    appendToFrameworks(this._frameworks, allFrameworks);
                }
                ui.debug(`Required frameworks: ${this.frameworks.map(f => f.name).join(' ')}`);
                /* Get scan frameworks */
                let scanFrameworks = configs.scanFrameworks;
                if (!scanFrameworks || scanFrameworks.includes('all')) {
                    /* Use all the available frameworks */
                    scanFrameworks = Object.keys(this._frameworks);
                }
                for (let frameworkName of scanFrameworks) {
                    this._frameworks[frameworkName].isInstalled = true;
                }
                completedTasks++;
                progress(completedTasks / tasksCount);
                ui.debug(`Loaded frameworks ${this.frameworksNames}`);
                this._isInitialized = true;
                return true;
            }));
        });
    }
}
exports.KubescapeApi = KubescapeApi;
KubescapeApi._instance = undefined;
//# sourceMappingURL=index.js.map