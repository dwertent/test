/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import "../common/ipc/cluster";
import type http from "http";
import type { Cluster } from "../common/cluster/cluster";
import { KubernetesCluster, LensKubernetesClusterStatus } from "../common/catalog-entities/kubernetes-cluster";
import type { ClusterStore } from "../common/cluster-store/cluster-store";
import type { ClusterId } from "../common/cluster-types";
import type { CatalogEntityRegistry } from "./catalog";
interface Dependencies {
    store: ClusterStore;
    catalogEntityRegistry: CatalogEntityRegistry;
}
export declare class ClusterManager {
    private dependencies;
    deleting: import("mobx").ObservableSet<string>;
    visibleCluster: ClusterId | undefined;
    constructor(dependencies: Dependencies);
    init: () => void;
    protected updateCatalog(clusters: Cluster[]): void;
    protected updateEntityFromCluster(cluster: Cluster): void;
    protected updateEntityStatus(entity: KubernetesCluster, cluster?: Cluster): void;
    protected syncClustersFromCatalog(entities: KubernetesCluster[]): void;
    protected onNetworkOffline: () => void;
    protected onNetworkOnline: () => void;
    stop(): void;
    getClusterForRequest: (req: http.IncomingMessage) => Cluster | undefined;
}
export declare function catalogEntityFromCluster(cluster: Cluster): KubernetesCluster<{
    uid: string;
    name: string;
    source: string;
    labels: {
        [x: string]: string;
    };
    distro: string;
    kubeVersion: string;
}, {
    phase: LensKubernetesClusterStatus;
    reason: string;
    message: string;
    active: boolean;
}, {
    kubeconfigPath: string;
    kubeconfigContext: string;
    icon: {};
}>;
export {};
