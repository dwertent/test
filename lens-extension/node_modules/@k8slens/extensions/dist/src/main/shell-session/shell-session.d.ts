/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { Cluster } from "../../common/cluster/cluster";
import type { Kubectl } from "../kubectl/kubectl";
import type WebSocket from "ws";
import * as pty from "node-pty";
import { type TerminalMessage } from "../../common/terminal/channels";
export declare class ShellOpenError extends Error {
    constructor(message: string, options?: ErrorOptions);
}
export declare enum WebSocketCloseEvent {
    /**
     * The connection successfully completed the purpose for which it was created.
     */
    NormalClosure = 1000,
    /**
     * The endpoint is going away, either because of a server failure or because
     * the browser is navigating away from the page that opened the connection.
     */
    GoingAway = 1001,
    /**
     * The endpoint is terminating the connection due to a protocol error.
     */
    ProtocolError = 1002,
    /**
     * The connection is being terminated because the endpoint received data of a
     * type it cannot accept. (For example, a text-only endpoint received binary
     * data.)
     */
    UnsupportedData = 1003,
    /**
     * Indicates that no status code was provided even though one was expected.
     */
    NoStatusReceived = 1005,
    /**
     * Indicates that a connection was closed abnormally (that is, with no close
     * frame being sent) when a status code is expected.
     */
    AbnormalClosure = 1006,
    /**
     *  The endpoint is terminating the connection because a message was received
     * that contained inconsistent data (e.g., non-UTF-8 data within a text message).
     */
    InvalidFramePayloadData = 1007,
    /**
     * The endpoint is terminating the connection because it received a message
     * that violates its policy. This is a generic status code, used when codes
     * 1003 and 1009 are not suitable.
     */
    PolicyViolation = 1008,
    /**
     * The endpoint is terminating the connection because a data frame was
     * received that is too large.
     */
    MessageTooBig = 1009,
    /**
     * The client is terminating the connection because it expected the server to
     * negotiate one or more extension, but the server didn't.
     */
    MissingExtension = 1010,
    /**
     * The server is terminating the connection because it encountered an
     * unexpected condition that prevented it from fulfilling the request.
     */
    InternalError = 1011,
    /**
     * The server is terminating the connection because it is restarting.
     */
    ServiceRestart = 1012,
    /**
     * The server is terminating the connection due to a temporary condition,
     * e.g. it is overloaded and is casting off some of its clients.
     */
    TryAgainLater = 1013,
    /**
     * The server was acting as a gateway or proxy and received an invalid
     * response from the upstream server. This is similar to 502 HTTP Status Code.
     */
    BadGateway = 1014,
    /**
     * Indicates that the connection was closed due to a failure to perform a TLS
     * handshake (e.g., the server certificate can't be verified).
     */
    TlsHandshake = 1015
}
export declare abstract class ShellSession {
    protected readonly kubectl: Kubectl;
    protected readonly websocket: WebSocket;
    protected readonly cluster: Cluster;
    abstract readonly ShellType: string;
    private static readonly shellEnvs;
    private static readonly processes;
    /**
     * Kill all remaining shell backing processes. Should be called when about to
     * quit
     */
    static cleanup(): void;
    protected running: boolean;
    protected readonly kubectlBinDirP: Promise<string>;
    protected readonly kubeconfigPathP: Promise<string>;
    protected readonly terminalId: string;
    protected abstract get cwd(): string | undefined;
    protected ensureShellProcess(shell: string, args: string[], env: Record<string, string | undefined>, cwd: string): {
        shellProcess: pty.IPty;
        resume: boolean;
    };
    constructor(kubectl: Kubectl, websocket: WebSocket, cluster: Cluster, terminalId: string);
    protected send(message: TerminalMessage): void;
    protected getCwd(env: Record<string, string | undefined>): Promise<string>;
    protected openShellProcess(shell: string, args: string[], env: Record<string, string | undefined>): Promise<void>;
    protected getPathEntries(): string[];
    protected getCachedShellEnv(): Promise<Record<string, string | undefined>>;
    protected getShellEnv(): Promise<Record<string, any>>;
    protected exit(code?: WebSocketCloseEvent): void;
}
