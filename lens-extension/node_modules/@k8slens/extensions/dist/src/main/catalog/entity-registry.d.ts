/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import { type IComputedValue, type IObservableArray } from "mobx";
import type { CatalogEntity } from "../../common/catalog";
import type { HasCategoryForEntity } from "../../common/catalog/has-category-for-entity.injectable";
interface Dependencies {
    readonly hasCategoryForEntity: HasCategoryForEntity;
}
export declare class CatalogEntityRegistry {
    protected readonly dependencies: Dependencies;
    protected sources: import("mobx").ObservableMap<string, IComputedValue<CatalogEntity<import("../../common/catalog").CatalogEntityMetadata, import("../../common/catalog").CatalogEntityStatus, import("../../common/catalog").CatalogEntitySpec>[]>>;
    constructor(dependencies: Dependencies);
    addObservableSource(id: string, source: IObservableArray<CatalogEntity>): void;
    addComputedSource(id: string, source: IComputedValue<CatalogEntity[]>): void;
    removeSource(id: string): void;
    get items(): CatalogEntity[];
    findById(id: string): CatalogEntity | undefined;
    filterItemsForApiKind(apiVersion: string, kind: string): CatalogEntity[];
    filterItemsByPredicate<E extends CatalogEntity>(filter: (item: CatalogEntity) => item is E): E[];
}
export {};
