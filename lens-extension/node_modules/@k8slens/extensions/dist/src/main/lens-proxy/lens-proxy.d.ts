/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
/// <reference types="node" />
import type http from "http";
import type httpProxy from "http-proxy";
import type { Router } from "../router/router";
import type { ClusterContextHandler } from "../context-handler/context-handler";
import type { Cluster } from "../../common/cluster/cluster";
import type { ProxyApiRequestArgs } from "./proxy-functions";
import type { SetRequired } from "type-fest";
declare type GetClusterForRequest = (req: http.IncomingMessage) => Cluster | undefined;
export declare type ServerIncomingMessage = SetRequired<http.IncomingMessage, "url" | "method">;
interface Dependencies {
    getClusterForRequest: GetClusterForRequest;
    shellApiRequest: (args: ProxyApiRequestArgs) => void | Promise<void>;
    kubeApiUpgradeRequest: (args: ProxyApiRequestArgs) => void | Promise<void>;
    router: Router;
    proxy: httpProxy;
    lensProxyPort: {
        set: (portNumber: number) => void;
    };
}
export declare function isLongRunningRequest(reqUrl: string): boolean;
export declare class LensProxy {
    private dependencies;
    protected proxyServer: http.Server;
    protected closed: boolean;
    protected retryCounters: Map<string, number>;
    constructor(dependencies: Dependencies);
    /**
     * Starts to listen on an OS provided port. Will reject if the server throws
     * an error.
     *
     * Resolves with the port number that was picked
     */
    private attemptToListen;
    /**
     * Starts the lens proxy.
     * @resolves After the server is listening on a good port
     * @rejects if there is an error before that happens
     */
    listen(): Promise<void>;
    close(): void;
    protected configureProxy(proxy: httpProxy): httpProxy;
    protected getProxyTarget(req: http.IncomingMessage, contextHandler: ClusterContextHandler): Promise<httpProxy.ServerOptions | void>;
    protected getRequestId(req: http.IncomingMessage): string;
    protected handleRequest(req: ServerIncomingMessage, res: http.ServerResponse): Promise<void>;
}
export {};
