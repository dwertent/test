/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import * as proto from "../../../common/protocol-handler";
import URLParse from "url-parse";
import type { LensExtension } from "../../../extensions/lens-extension";
import type { LensProtocolRouterDependencies, RouteAttempt } from "../../../common/protocol-handler";
export interface FallbackHandler {
    (name: string): Promise<boolean>;
}
export interface LensProtocolRouterMainDependencies extends LensProtocolRouterDependencies {
    showApplicationWindow: () => Promise<void>;
}
export declare class LensProtocolRouterMain extends proto.LensProtocolRouter {
    protected readonly dependencies: LensProtocolRouterMainDependencies;
    private missingExtensionHandlers;
    rendererLoaded: boolean;
    protected disposers: import("../../../common/utils").ExtendableDisposer;
    constructor(dependencies: LensProtocolRouterMainDependencies);
    cleanup(): void;
    /**
     * Find the most specific registered handler, if it exists, and invoke it.
     *
     * This will send an IPC message to the renderer router to do the same
     * in the renderer.
     */
    route(rawUrl: string): Promise<void>;
    protected _executeMissingExtensionHandlers(extensionName: string): Promise<boolean>;
    protected _findMatchingExtensionByName(url: URLParse<Record<string, string>>): Promise<LensExtension | string>;
    protected _routeToInternal(url: URLParse<Record<string, string | undefined>>): RouteAttempt;
    protected _routeToExtension(url: URLParse<Record<string, string | undefined>>): Promise<RouteAttempt>;
    /**
     * Add a function to the list which will be sequentially called if an extension
     * is not found while routing to the extensions
     * @param handler A function that tries to find an extension
     */
    addMissingExtensionHandler(handler: FallbackHandler): void;
}
