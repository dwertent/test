/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
/// <reference types="node" />
import { EventEmitter } from "events";
import type { ExtensionsStore } from "../extensions-store/extensions-store";
import type { ExtensionLoader } from "../extension-loader";
import type { LensExtensionId, LensExtensionManifest } from "../lens-extension";
import type { ExtensionInstallationStateStore } from "../extension-installation-state-store/extension-installation-state-store";
import type { PackageJson } from "type-fest";
interface Dependencies {
    extensionLoader: ExtensionLoader;
    extensionsStore: ExtensionsStore;
    extensionInstallationStateStore: ExtensionInstallationStateStore;
    isCompatibleBundledExtension: (manifest: LensExtensionManifest) => boolean;
    isCompatibleExtension: (manifest: LensExtensionManifest) => boolean;
    installExtension: (name: string) => Promise<void>;
    installExtensions: (packageJsonPath: string, packagesJson: PackageJson) => Promise<void>;
    extensionPackageRootDirectory: string;
    staticFilesDirectory: string;
}
export interface InstalledExtension {
    id: LensExtensionId;
    readonly manifest: LensExtensionManifest;
    readonly absolutePath: string;
    readonly manifestPath: string;
    readonly isBundled: boolean;
    readonly isCompatible: boolean;
    isEnabled: boolean;
}
export declare const manifestFilename = "package.json";
interface ExtensionDiscoveryChannelMessage {
    isLoaded: boolean;
}
interface LoadFromFolderOptions {
    isBundled?: boolean;
}
/**
 * Discovers installed bundled and local extensions from the filesystem.
 * Also watches for added and removed local extensions by watching the directory.
 * Uses ExtensionInstaller to install dependencies for all of the extensions.
 * This is also done when a new extension is copied to the local extensions directory.
 * .init() must be called to start the directory watching.
 * The class emits events for added and removed extensions:
 * - "add": When extension is added. The event is of type InstalledExtension
 * - "remove": When extension is removed. The event is of type LensExtensionId
 */
export declare class ExtensionDiscovery {
    protected dependencies: Dependencies;
    protected bundledFolderPath: string;
    private loadStarted;
    private extensions;
    isLoaded: boolean;
    get whenLoaded(): Promise<void> & {
        cancel(): void;
    };
    events: EventEmitter;
    constructor(dependencies: Dependencies);
    get localFolderPath(): string;
    get packageJsonPath(): string;
    get inTreeTargetPath(): string;
    get inTreeFolderPath(): string;
    get nodeModulesPath(): string;
    /**
     * Initializes the class and setups the file watcher for added/removed local extensions.
     */
    init(): Promise<void>;
    initRenderer(): Promise<void>;
    initMain(): Promise<void>;
    /**
     * Watches for added/removed local extensions.
     * Dependencies are installed automatically after an extension folder is copied.
     */
    watchExtensions(): Promise<void>;
    handleWatchFileAdd: (manifestPath: string) => Promise<void>;
    /**
     * Handle any unlink event, filtering out non-package.json links so the delete code
     * only happens once per extension.
     * @param filePath The absolute path to either a folder or file in the extensions folder
     */
    handleWatchUnlinkEvent: (filePath: string) => Promise<void>;
    /**
     * Remove the symlink under node_modules if exists.
     * If we don't remove the symlink, the uninstall would leave a non-working symlink,
     * which wouldn't be fixed if the extension was reinstalled, causing the extension not to work.
     * @param name e.g. "@mirantis/lens-extension-cc"
     */
    removeSymlinkByPackageName(name: string): Promise<void>;
    /**
     * Uninstalls extension.
     * The application will detect the folder unlink and remove the extension from the UI automatically.
     * @param extensionId The ID of the extension to uninstall.
     */
    uninstallExtension(extensionId: LensExtensionId): Promise<void>;
    load(): Promise<Map<LensExtensionId, InstalledExtension>>;
    /**
     * Returns the symlinked path to the extension folder,
     * e.g. "/Users/<username>/Library/Application Support/Lens/node_modules/@publisher/extension"
     */
    protected getInstalledPath(name: string): string;
    /**
     * Returns the symlinked path to the package.json,
     * e.g. "/Users/<username>/Library/Application Support/Lens/node_modules/@publisher/extension/package.json"
     */
    protected getInstalledManifestPath(name: string): string;
    /**
     * Returns InstalledExtension from path to package.json file.
     * Also updates this.packagesJson.
     */
    protected getByManifest(manifestPath: string, { isBundled }?: {
        isBundled?: boolean | undefined;
    }): Promise<InstalledExtension | null>;
    ensureExtensions(): Promise<Map<LensExtensionId, InstalledExtension>>;
    /**
     * Write package.json to file system and install dependencies.
     */
    installBundledPackages(packageJsonPath: string, extensions: InstalledExtension[]): Promise<void>;
    loadBundledExtensions(): Promise<InstalledExtension[]>;
    loadFromFolder(folderPath: string, bundledExtensions: string[]): Promise<InstalledExtension[]>;
    /**
     * Loads extension from absolute path, updates this.packagesJson to include it and returns the extension.
     * @param folderPath Folder path to extension
     */
    loadExtensionFromFolder(folderPath: string, { isBundled }?: LoadFromFolderOptions): Promise<InstalledExtension | null>;
    toJSON(): ExtensionDiscoveryChannelMessage;
    broadcast(): void;
}
export {};
