/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { match } from "react-router";
import type Url from "url-parse";
import type { ExtensionsStore } from "../../extensions/extensions-store/extensions-store";
import type { ExtensionLoader } from "../../extensions/extension-loader";
import type { LensExtension } from "../../extensions/lens-extension";
import type { RouteHandler } from "../../extensions/registries/protocol-handler";
export declare const ProtocolHandlerIpcPrefix = "protocol-handler";
export declare const ProtocolHandlerInternal: string;
export declare const ProtocolHandlerExtension: string;
export declare const ProtocolHandlerInvalid: string;
/**
 * These two names are long and cumbersome by design so as to decrease the chances
 * of an extension using the same names.
 *
 * Though under the current (2021/01/18) implementation, these are never matched
 * against in the final matching so their names are less of a concern.
 */
export declare const EXTENSION_PUBLISHER_MATCH = "LENS_INTERNAL_EXTENSION_PUBLISHER_MATCH";
export declare const EXTENSION_NAME_MATCH = "LENS_INTERNAL_EXTENSION_NAME_MATCH";
/**
 * Returned from routing attempts
 */
export declare enum RouteAttempt {
    /**
     * A handler was found in the set of registered routes
     */
    MATCHED = "matched",
    /**
     * A handler was not found within the set of registered routes
     */
    MISSING = "missing",
    /**
     * The extension that was matched in the route was not activated
     */
    MISSING_EXTENSION = "no-extension"
}
export declare function foldAttemptResults(mainAttempt: RouteAttempt, rendererAttempt: RouteAttempt): RouteAttempt;
export interface LensProtocolRouterDependencies {
    readonly extensionLoader: ExtensionLoader;
    readonly extensionsStore: ExtensionsStore;
}
export declare abstract class LensProtocolRouter {
    protected readonly dependencies: LensProtocolRouterDependencies;
    protected internalRoutes: Map<string, RouteHandler>;
    static readonly LoggingPrefix = "[PROTOCOL ROUTER]";
    static readonly ExtensionUrlSchema: string;
    constructor(dependencies: LensProtocolRouterDependencies);
    /**
     * Attempts to route the given URL to all internal routes that have been registered
     * @param url the parsed URL that initiated the `lens://` protocol
     * @returns true if a route has been found
     */
    protected _routeToInternal(url: Url<Record<string, string | undefined>>): RouteAttempt;
    /**
     * match against all matched URIs, returning either the first exact match or
     * the most specific match if none are exact.
     * @param routes the array of path schemas, handler pairs to match against
     * @param url the url (in its current state)
     */
    protected _findMatchingRoute(routes: Iterable<[string, RouteHandler]>, url: Url<Record<string, string | undefined>>): null | [match<Record<string, string>>, RouteHandler];
    /**
     * find the most specific matching handler and call it
     * @param routes the array of (path schemas, handler) pairs to match against
     * @param url the url (in its current state)
     */
    protected _route(routes: Iterable<[string, RouteHandler]>, url: Url<Record<string, string | undefined>>, extensionName?: string): RouteAttempt;
    /**
     * Tries to find the matching LensExtension instance
     *
     * Note: this needs to be async so that `main`'s overloaded version can also be async
     * @param url the protocol request URI that was "open"-ed
     * @returns either the found name or the instance of `LensExtension`
     */
    protected _findMatchingExtensionByName(url: Url<Record<string, string | undefined>>): Promise<LensExtension | string>;
    /**
     * Find a matching extension by the first one or two path segments of `url` and then try to `_route`
     * its correspondingly registered handlers.
     *
     * If no handlers are found or the extension is not enabled then `_missingHandlers` is called before
     * checking if more handlers have been added.
     *
     * Note: this function modifies its argument, do not reuse
     * @param url the protocol request URI that was "open"-ed
     */
    protected _routeToExtension(url: Url<Record<string, string | undefined>>): Promise<RouteAttempt>;
    /**
     * Add a handler under the `lens://app` tree of routing.
     * @param pathSchema the URI path schema to match against for this handler
     * @param handler a function that will be called if a protocol path matches
     */
    addInternalHandler(urlSchema: string, handler: RouteHandler): this;
    /**
     * Remove an internal protocol handler.
     * @param pathSchema the path schema that the handler was registered under
     */
    removeInternalHandler(urlSchema: string): void;
}
