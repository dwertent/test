/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { ClusterContextHandler } from "../../main/context-handler/context-handler";
import type { KubeConfig } from "@kubernetes/client-node";
import type { Kubectl } from "../../main/kubectl/kubectl";
import type { KubeconfigManager } from "../../main/kubeconfig-manager/kubeconfig-manager";
import type { KubeResource } from "../rbac";
import type { VersionDetector } from "../../main/cluster-detectors/version-detector";
import type { DetectorRegistry } from "../../main/cluster-detectors/detector-registry";
import type { ClusterState, ClusterRefreshOptions, ClusterMetricsResourceType, ClusterId, ClusterMetadata, ClusterModel, ClusterPreferences, ClusterPrometheusPreferences, UpdateClusterModel, ClusterConfigData } from "../cluster-types";
import { ClusterStatus } from "../cluster-types";
import type { CanI } from "./authorization-review.injectable";
import type { ListNamespaces } from "./list-namespaces.injectable";
import type { Logger } from "../logger";
export interface ClusterDependencies {
    readonly directoryForKubeConfigs: string;
    readonly logger: Logger;
    readonly detectorRegistry: DetectorRegistry;
    createKubeconfigManager: (cluster: Cluster) => KubeconfigManager;
    createContextHandler: (cluster: Cluster) => ClusterContextHandler;
    createKubectl: (clusterVersion: string) => Kubectl;
    createAuthorizationReview: (config: KubeConfig) => CanI;
    createListNamespaces: (config: KubeConfig) => ListNamespaces;
    createVersionDetector: (cluster: Cluster) => VersionDetector;
}
/**
 * Cluster
 *
 * @beta
 */
export declare class Cluster implements ClusterModel, ClusterState {
    private readonly dependencies;
    /** Unique id for a cluster */
    readonly id: ClusterId;
    private kubeCtl;
    /**
     * Context handler
     *
     * @internal
     */
    protected readonly _contextHandler: ClusterContextHandler | undefined;
    protected readonly _proxyKubeconfigManager: KubeconfigManager | undefined;
    protected readonly eventsDisposer: import("../utils").ExtendableDisposer;
    protected activated: boolean;
    private readonly resourceAccessStatuses;
    get contextHandler(): ClusterContextHandler;
    protected get proxyKubeconfigManager(): KubeconfigManager;
    get whenReady(): Promise<void> & {
        cancel(): void;
    };
    /**
     * Kubeconfig context name
     *
     * @observable
     */
    contextName: string;
    /**
     * Path to kubeconfig
     *
     * @observable
     */
    kubeConfigPath: string;
    /**
     * @deprecated
     */
    workspace?: string;
    /**
     * @deprecated
     */
    workspaces?: string[];
    /**
     * Kubernetes API server URL
     *
     * @observable
     */
    apiUrl: string;
    /**
     * Is cluster online
     *
     * @observable
     */
    online: boolean;
    /**
     * Can user access cluster resources
     *
     * @observable
     */
    accessible: boolean;
    /**
     * Is cluster instance in usable state
     *
     * @observable
     */
    ready: boolean;
    /**
     * Is cluster currently reconnecting
     *
     * @observable
     */
    reconnecting: boolean;
    /**
     * Is cluster disconnected. False if user has selected to connect.
     *
     * @observable
     */
    disconnected: boolean;
    /**
     * Does user have admin like access
     *
     * @observable
     */
    isAdmin: boolean;
    /**
     * Global watch-api accessibility , e.g. "/api/v1/services?watch=1"
     *
     * @observable
     */
    isGlobalWatchEnabled: boolean;
    /**
     * Preferences
     *
     * @observable
     */
    preferences: ClusterPreferences;
    /**
     * Metadata
     *
     * @observable
     */
    metadata: ClusterMetadata;
    /**
     * List of allowed namespaces verified via K8S::SelfSubjectAccessReview api
     *
     * @observable
     */
    allowedNamespaces: string[];
    /**
     * List of allowed resources
     *
     * @observable
     * @internal
     */
    allowedResources: string[];
    /**
     * List of accessible namespaces provided by user in the Cluster Settings
     *
     * @observable
     */
    accessibleNamespaces: string[];
    /**
     * Labels for the catalog entity
     */
    labels: Record<string, string>;
    /**
     * Is cluster available
     *
     * @computed
     */
    get available(): boolean;
    /**
     * Cluster name
     *
     * @computed
     */
    get name(): string;
    /**
     * The detected kubernetes distribution
     */
    get distribution(): string;
    /**
     * The detected kubernetes version
     */
    get version(): string;
    /**
     * Prometheus preferences
     *
     * @computed
     * @internal
     */
    get prometheusPreferences(): ClusterPrometheusPreferences;
    /**
     * defaultNamespace preference
     *
     * @computed
     * @internal
     */
    get defaultNamespace(): string | undefined;
    constructor(dependencies: ClusterDependencies, model: ClusterModel, configData: ClusterConfigData);
    /**
     * Update cluster data model
     *
     * @param model
     */
    updateModel(model: UpdateClusterModel): void;
    /**
     * @internal
     */
    protected bindEvents(): void;
    /**
     * @internal
     */
    protected recreateProxyKubeconfig(): Promise<void>;
    /**
     * @param force force activation
     * @internal
     */
    activate(force?: boolean): Promise<void>;
    /**
     * @internal
     */
    ensureKubectl(): Promise<Kubectl>;
    /**
     * @internal
     */
    reconnect(): Promise<void>;
    /**
     * @internal
     */
    disconnect(): void;
    /**
     * @internal
     * @param opts refresh options
     */
    refresh(opts?: ClusterRefreshOptions): Promise<void>;
    /**
     * @internal
     */
    refreshMetadata(): Promise<void>;
    /**
     * @internal
     */
    private refreshAccessibility;
    /**
     * @internal
     */
    refreshConnectionStatus(): Promise<void>;
    getKubeconfig(): Promise<KubeConfig>;
    /**
     * @internal
     */
    getProxyKubeconfig(): Promise<KubeConfig>;
    /**
     * @internal
     */
    getProxyKubeconfigPath(): Promise<string>;
    protected getConnectionStatus(): Promise<ClusterStatus>;
    toJSON(): ClusterModel;
    /**
     * Serializable cluster-state used for sync btw main <-> renderer
     */
    getState(): ClusterState;
    /**
     * @internal
     * @param state cluster state
     */
    setState(state: ClusterState): void;
    /**
     * @internal
     * @param state cluster state
     */
    pushState(state?: ClusterState): void;
    getMeta(): {
        id: string;
        name: string;
        ready: boolean;
        online: boolean;
        accessible: boolean;
        disconnected: boolean;
    };
    /**
     * broadcast an authentication update concerning this cluster
     * @internal
     */
    broadcastConnectUpdate(message: string, isError?: boolean): void;
    protected getAllowedNamespaces(proxyConfig: KubeConfig): Promise<string[]>;
    protected getAllowedResources(canI: CanI): Promise<KubeResource[]>;
    isAllowedResource(kind: string): boolean;
    isMetricHidden(resource: ClusterMetricsResourceType): boolean;
    get nodeShellImage(): string;
    get imagePullSecret(): string | undefined;
    isInLocalKubeconfig(): boolean;
}
