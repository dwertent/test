/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { MetricData } from "./metrics.api";
import type { DerivedKubeApiOptions, IgnoredKubeApiOptions, ResourceDescriptor } from "../kube-api";
import { KubeApi } from "../kube-api";
import type { RequireExactlyOne } from "type-fest";
import type { KubeObjectMetadata, LocalObjectReference, Affinity, Toleration, LabelSelector, NamespaceScopedMetadata } from "../kube-object";
import type { SecretReference } from "./secret.api";
import type { PersistentVolumeClaimSpec } from "./persistent-volume-claim.api";
import { KubeObject } from "../kube-object";
export declare class PodApi extends KubeApi<Pod> {
    constructor(opts?: DerivedKubeApiOptions & IgnoredKubeApiOptions);
    getLogs(params: ResourceDescriptor, query?: PodLogsQuery): Promise<string>;
}
export declare function getMetricsForPods(pods: Pod[], namespace: string, selector?: string): Promise<PodMetricData>;
export interface PodMetricData extends Partial<Record<string, MetricData>> {
    cpuUsage: MetricData;
    memoryUsage: MetricData;
    fsUsage: MetricData;
    fsWrites: MetricData;
    fsReads: MetricData;
    networkReceive: MetricData;
    networkTransmit: MetricData;
    cpuRequests?: MetricData;
    cpuLimits?: MetricData;
    memoryRequests?: MetricData;
    memoryLimits?: MetricData;
}
export interface PodLogsQuery {
    container?: string;
    tailLines?: number;
    timestamps?: boolean;
    sinceTime?: string;
    follow?: boolean;
    previous?: boolean;
}
export declare enum PodStatusPhase {
    TERMINATED = "Terminated",
    FAILED = "Failed",
    PENDING = "Pending",
    RUNNING = "Running",
    SUCCEEDED = "Succeeded",
    EVICTED = "Evicted"
}
export interface ContainerPort {
    containerPort: number;
    hostIP?: string;
    hostPort?: number;
    name?: string;
    protocol?: "UDP" | "TCP" | "SCTP";
}
export interface VolumeMount {
    name: string;
    readOnly?: boolean;
    mountPath: string;
    mountPropagation?: string;
    subPath?: string;
    subPathExpr?: string;
}
export interface PodContainer extends Partial<Record<PodContainerProbe, IContainerProbe>> {
    name: string;
    image: string;
    command?: string[];
    args?: string[];
    ports?: ContainerPort[];
    resources?: {
        limits?: {
            cpu: string;
            memory: string;
        };
        requests?: {
            cpu: string;
            memory: string;
        };
    };
    terminationMessagePath?: string;
    terminationMessagePolicy?: string;
    env?: {
        name: string;
        value?: string;
        valueFrom?: {
            fieldRef?: {
                apiVersion: string;
                fieldPath: string;
            };
            secretKeyRef?: {
                key: string;
                name: string;
            };
            configMapKeyRef?: {
                key: string;
                name: string;
            };
        };
    }[];
    envFrom?: {
        configMapRef?: LocalObjectReference;
        secretRef?: LocalObjectReference;
    }[];
    volumeMounts?: VolumeMount[];
    imagePullPolicy?: string;
}
export declare type PodContainerProbe = "livenessProbe" | "readinessProbe" | "startupProbe";
interface IContainerProbe {
    httpGet?: {
        path?: string;
        /**
         * either a port number or an IANA_SVC_NAME string referring to a port defined in the container
         */
        port: number | string;
        scheme: string;
        host?: string;
    };
    exec?: {
        command: string[];
    };
    tcpSocket?: {
        port: number;
    };
    initialDelaySeconds?: number;
    timeoutSeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    failureThreshold?: number;
}
export interface ContainerStateRunning {
    startedAt: string;
}
export interface ContainerStateWaiting {
    reason: string;
    message: string;
}
export interface ContainerStateTerminated {
    startedAt: string;
    finishedAt: string;
    exitCode: number;
    reason: string;
    containerID?: string;
    message?: string;
    signal?: number;
}
/**
 * ContainerState holds a possible state of container. Only one of its members
 * may be specified. If none of them is specified, the default one is
 * `ContainerStateWaiting`.
 */
export interface ContainerState {
    running?: ContainerStateRunning;
    waiting?: ContainerStateWaiting;
    terminated?: ContainerStateTerminated;
}
export interface PodContainerStatus {
    name: string;
    state?: ContainerState;
    lastState?: ContainerState;
    ready: boolean;
    restartCount: number;
    image: string;
    imageID: string;
    containerID?: string;
    started?: boolean;
}
export interface AwsElasticBlockStoreSource {
    volumeID: string;
    fsType: string;
}
export interface AzureDiskSource {
    /**
     * The name of the VHD blob object OR the name of an Azure managed data disk if `kind` is `"Managed"`.
     */
    diskName: string;
    /**
     * The URI of the vhd blob object OR the `resourceID` of an Azure managed data disk if `kind` is `"Managed"`.
     */
    diskURI: string;
    /**
     * Kind of disk
     * @default "Shared"
     */
    kind?: "Shared" | "Dedicated" | "Managed";
    /**
     * Disk caching mode.
     * @default "None"
     */
    cachingMode?: "None" | "ReadOnly" | "ReadWrite";
    /**
     * The filesystem type to mount.
     * @default "ext4"
     */
    fsType?: string;
    /**
     * Whether the filesystem is used as readOnly.
     * @default false
     */
    readonly?: boolean;
}
export interface AzureFileSource {
    /**
     * The name of the secret that contains both Azure storage account name and key.
     */
    secretName: string;
    /**
     * The share name to be used.
     */
    shareName: string;
    /**
     * In case the secret is stored in a different namespace.
     * @default "default"
     */
    secretNamespace?: string;
    /**
     * Whether the filesystem is used as readOnly.
     */
    readOnly: boolean;
}
export interface CephfsSource {
    /**
     * List of Ceph monitors
     */
    monitors: string[];
    /**
     * Used as the mounted root, rather than the full Ceph tree.
     * @default "/"
     */
    path?: string;
    /**
     * The RADOS user name.
     * @default "admin"
     */
    user?: string;
    /**
     * The path to the keyring file.
     * @default "/etc/ceph/user.secret"
     */
    secretFile?: string;
    /**
     * Reference to Ceph authentication secrets. If provided, then the secret overrides `secretFile`
     */
    secretRef?: SecretReference;
    /**
     * Whether the filesystem is used as readOnly.
     *
     * @default false
     */
    readOnly?: boolean;
}
export interface CinderSource {
    volumeID: string;
    fsType: string;
    /**
     * @default false
     */
    readOnly?: boolean;
    secretRef?: SecretReference;
}
export interface ConfigMapSource {
    name: string;
    items: {
        key: string;
        path: string;
    }[];
}
export interface DownwardApiSource {
    items: {
        path: string;
        fieldRef: {
            fieldPath: string;
        };
    }[];
}
export interface EphemeralSource {
    volumeClaimTemplate: {
        /**
         * All the rest of the fields are ignored and rejected during validation
         */
        metadata?: Pick<KubeObjectMetadata, "labels" | "annotations">;
        spec: PersistentVolumeClaimSpec;
    };
}
export interface EmptyDirSource {
    medium?: string;
    sizeLimit?: string;
}
export interface FiberChannelSource {
    /**
     * A list of World Wide Names
     */
    targetWWNs: string[];
    /**
     * Logical Unit number
     */
    lun: number;
    /**
     * The type of filesystem
     * @default "ext4"
     */
    fsType?: string;
    readOnly: boolean;
}
export interface FlockerSource {
    datasetName: string;
}
export interface FlexVolumeSource {
    driver: string;
    fsType?: string;
    secretRef?: LocalObjectReference;
    /**
     * @default false
     */
    readOnly?: boolean;
    options?: Record<string, string>;
}
export interface GcePersistentDiskSource {
    pdName: string;
    fsType: string;
}
export interface GitRepoSource {
    repository: string;
    revision: string;
}
export interface GlusterFsSource {
    /**
     * The name of the Endpoints object that represents a Gluster cluster configuration.
     */
    endpoints: string;
    /**
     * The Glusterfs volume name.
     */
    path: string;
    /**
     * The boolean that sets the mountpoint readOnly or readWrite.
     */
    readOnly: boolean;
}
export interface HostPathSource {
    path: string;
    /**
     * Determines the sorts of checks that will be done
     * @default ""
     */
    type?: "" | "DirectoryOrCreate" | "Directory" | "FileOrCreate" | "File" | "Socket" | "CharDevice" | "BlockDevice";
}
export interface IScsiSource {
    targetPortal: string;
    iqn: string;
    lun: number;
    fsType: string;
    readOnly: boolean;
    chapAuthDiscovery?: boolean;
    chapAuthSession?: boolean;
    secretRef?: SecretReference;
}
export interface LocalSource {
    path: string;
}
export interface NetworkFsSource {
    server: string;
    path: string;
    readOnly?: boolean;
}
export interface PersistentVolumeClaimSource {
    claimName: string;
}
export interface PhotonPersistentDiskSource {
    pdID: string;
    /**
     * @default "ext4"
     */
    fsType?: string;
}
export interface PortworxVolumeSource {
    volumeID: string;
    fsType?: string;
    readOnly?: boolean;
}
export interface KeyToPath {
    key: string;
    path: string;
    mode?: number;
}
export interface ConfigMapProjection {
    name: string;
    items?: KeyToPath[];
    optional?: boolean;
}
export interface ObjectFieldSelector {
    fieldPath: string;
    apiVersion?: string;
}
export interface ResourceFieldSelector {
    resource: string;
    containerName?: string;
    divisor?: string;
}
export interface DownwardAPIVolumeFile {
    path: string;
    fieldRef?: ObjectFieldSelector;
    resourceFieldRef?: ResourceFieldSelector;
    mode?: number;
}
export interface DownwardAPIProjection {
    items?: DownwardAPIVolumeFile[];
}
export interface SecretProjection {
    name: string;
    items?: KeyToPath[];
    optional?: boolean;
}
export interface ServiceAccountTokenProjection {
    audience?: string;
    expirationSeconds?: number;
    path: string;
}
export interface VolumeProjection {
    secret?: SecretProjection;
    downwardAPI?: DownwardAPIProjection;
    configMap?: ConfigMapProjection;
    serviceAccountToken?: ServiceAccountTokenProjection;
}
export interface ProjectedSource {
    sources?: VolumeProjection[];
    defaultMode?: number;
}
export interface QuobyteSource {
    registry: string;
    volume: string;
    /**
     * @default false
     */
    readOnly?: boolean;
    /**
     * @default "serivceaccount"
     */
    user?: string;
    group?: string;
    tenant?: string;
}
export interface RadosBlockDeviceSource {
    monitors: string[];
    image: string;
    /**
     * @default "ext4"
     */
    fsType?: string;
    /**
     * @default "rbd"
     */
    pool?: string;
    /**
     * @default "admin"
     */
    user?: string;
    /**
     * @default "/etc/ceph/keyring"
     */
    keyring?: string;
    secretRef?: SecretReference;
    /**
     * @default false
     */
    readOnly?: boolean;
}
export interface ScaleIoSource {
    gateway: string;
    system: string;
    secretRef?: LocalObjectReference;
    /**
     * @default false
     */
    sslEnabled?: boolean;
    protectionDomain?: string;
    storagePool?: string;
    /**
     * @default "ThinProvisioned"
     */
    storageMode?: "ThickProvisioned" | "ThinProvisioned";
    volumeName: string;
    /**
     * @default "xfs"
     */
    fsType?: string;
    /**
     * @default false
     */
    readOnly?: boolean;
}
export interface SecretSource {
    secretName: string;
    items?: {
        key: string;
        path: string;
        mode?: number;
    }[];
    defaultMode?: number;
    optional?: boolean;
}
export interface StorageOsSource {
    volumeName: string;
    /**
     * @default Pod.metadata.namespace
     */
    volumeNamespace?: string;
    /**
     * @default "ext4"
     */
    fsType?: string;
    /**
     * @default false
     */
    readOnly?: boolean;
    secretRef?: LocalObjectReference;
}
export interface VsphereVolumeSource {
    volumePath: string;
    /**
     * @default "ext4"
     */
    fsType?: string;
    storagePolicyName?: string;
    storagePolicyID?: string;
}
export interface ContainerStorageInterfaceSource {
    driver: string;
    /**
     * @default false
     */
    readOnly?: boolean;
    /**
     * @default "ext4"
     */
    fsType?: string;
    volumeAttributes?: Record<string, string>;
    controllerPublishSecretRef?: SecretReference;
    nodeStageSecretRef?: SecretReference;
    nodePublishSecretRef?: SecretReference;
    controllerExpandSecretRef?: SecretReference;
}
export interface PodVolumeVariants {
    awsElasticBlockStore: AwsElasticBlockStoreSource;
    azureDisk: AzureDiskSource;
    azureFile: AzureFileSource;
    cephfs: CephfsSource;
    cinder: CinderSource;
    configMap: ConfigMapSource;
    csi: ContainerStorageInterfaceSource;
    downwardAPI: DownwardApiSource;
    emptyDir: EmptyDirSource;
    ephemeral: EphemeralSource;
    fc: FiberChannelSource;
    flexVolume: FlexVolumeSource;
    flocker: FlockerSource;
    gcePersistentDisk: GcePersistentDiskSource;
    gitRepo: GitRepoSource;
    glusterfs: GlusterFsSource;
    hostPath: HostPathSource;
    iscsi: IScsiSource;
    local: LocalSource;
    nfs: NetworkFsSource;
    persistentVolumeClaim: PersistentVolumeClaimSource;
    photonPersistentDisk: PhotonPersistentDiskSource;
    portworxVolume: PortworxVolumeSource;
    projected: ProjectedSource;
    quobyte: QuobyteSource;
    rbd: RadosBlockDeviceSource;
    scaleIO: ScaleIoSource;
    secret: SecretSource;
    storageos: StorageOsSource;
    vsphereVolume: VsphereVolumeSource;
}
/**
 * The valid kinds of volume
 */
export declare type PodVolumeKind = keyof PodVolumeVariants;
export declare type PodSpecVolume = RequireExactlyOne<PodVolumeVariants> & {
    name: string;
};
export interface HostAlias {
    ip: string;
    hostnames: string[];
}
export interface SELinuxOptions {
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}
export interface SeccompProfile {
    localhostProfile?: string;
    type: string;
}
export interface Sysctl {
    name: string;
    value: string;
}
export interface WindowsSecurityContextOptions {
    labelSelector?: LabelSelector;
    maxSkew: number;
    topologyKey: string;
    whenUnsatisfiable: string;
}
export interface PodSecurityContext {
    fsGroup?: number;
    fsGroupChangePolicy?: string;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    runAsUser?: number;
    seLinuxOptions?: SELinuxOptions;
    seccompProfile?: SeccompProfile;
    supplementalGroups?: number[];
    sysctls?: Sysctl;
    windowsOptions?: WindowsSecurityContextOptions;
}
export interface TopologySpreadConstraint {
}
export interface PodSpec {
    activeDeadlineSeconds?: number;
    affinity?: Affinity;
    automountServiceAccountToken?: boolean;
    containers?: PodContainer[];
    dnsPolicy?: string;
    enableServiceLinks?: boolean;
    ephemeralContainers?: unknown[];
    hostAliases?: HostAlias[];
    hostIPC?: boolean;
    hostname?: string;
    hostNetwork?: boolean;
    hostPID?: boolean;
    imagePullSecrets?: LocalObjectReference[];
    initContainers?: PodContainer[];
    nodeName?: string;
    nodeSelector?: Partial<Record<string, string>>;
    overhead?: Partial<Record<string, string>>;
    preemptionPolicy?: string;
    priority?: number;
    priorityClassName?: string;
    readinessGates?: unknown[];
    restartPolicy?: string;
    runtimeClassName?: string;
    schedulerName?: string;
    securityContext?: PodSecurityContext;
    serviceAccount?: string;
    serviceAccountName?: string;
    setHostnameAsFQDN?: boolean;
    shareProcessNamespace?: boolean;
    subdomain?: string;
    terminationGracePeriodSeconds?: number;
    tolerations?: Toleration[];
    topologySpreadConstraints?: TopologySpreadConstraint[];
    volumes?: PodSpecVolume[];
}
export interface PodCondition {
    lastProbeTime?: number;
    lastTransitionTime?: string;
    message?: string;
    reason?: string;
    type: string;
    status: string;
}
export interface PodStatus {
    phase: string;
    conditions: PodCondition[];
    hostIP: string;
    podIP: string;
    podIPs?: {
        ip: string;
    }[];
    startTime: string;
    initContainerStatuses?: PodContainerStatus[];
    containerStatuses?: PodContainerStatus[];
    qosClass?: string;
    reason?: string;
}
export declare class Pod extends KubeObject<NamespaceScopedMetadata, PodStatus, PodSpec> {
    static kind: string;
    static namespaced: boolean;
    static apiBase: string;
    getAffinityNumber(): number;
    getInitContainers(): PodContainer[];
    getContainers(): PodContainer[];
    getAllContainers(): PodContainer[];
    getRunningContainers(): PodContainer[];
    getContainerStatuses(includeInitContainers?: boolean): PodContainerStatus[];
    getRestartsCount(): number;
    getQosClass(): string;
    getReason(): string;
    getPriorityClassName(): string;
    getStatus(): PodStatusPhase;
    getStatusMessage(): string;
    getStatusPhase(): string | undefined;
    getConditions(): PodCondition[];
    getVolumes(): PodSpecVolume[];
    getSecrets(): string[];
    getNodeSelectors(): string[];
    getTolerations(): Toleration[];
    getAffinity(): Affinity;
    hasIssues(): boolean;
    getLivenessProbe(container: PodContainer): string[];
    getReadinessProbe(container: PodContainer): string[];
    getStartupProbe(container: PodContainer): string[];
    private getProbe;
    getNodeName(): string | undefined;
    getSelectedNodeOs(): string | undefined;
    getIPs(): string[];
}
export {};
