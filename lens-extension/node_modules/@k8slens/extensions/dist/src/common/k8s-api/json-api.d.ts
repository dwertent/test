/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { Response, RequestInit } from "node-fetch";
import type { Patch } from "rfc6902";
import type { PartialDeep, ValueOf } from "type-fest";
import { EventEmitter } from "../../common/event-emitter";
import type { Defaulted } from "../utils";
export interface JsonApiData {
}
export interface JsonApiError {
    code?: number;
    message?: string;
    errors?: {
        id: string;
        title: string;
        status?: number;
    }[];
}
export interface JsonApiParams<D> {
    data?: PartialDeep<D>;
}
export interface JsonApiLog {
    method: string;
    reqUrl: string;
    reqInit: RequestInit;
    data?: any;
    error?: any;
}
export declare type GetRequestOptions = () => Promise<RequestInit>;
export interface JsonApiConfig {
    apiBase: string;
    serverAddress: string;
    debug?: boolean;
    getRequestOptions?: GetRequestOptions;
}
export declare type QueryParam = string | number | boolean | null | undefined | readonly string[] | readonly number[] | readonly boolean[];
export declare type QueryParams = Partial<Record<string, QueryParam | undefined>>;
export declare type ParamsAndQuery<Params, Query> = (ValueOf<Query> extends QueryParam ? Params & {
    query?: Query;
} : Params & {
    query?: undefined;
});
export declare class JsonApi<Data = JsonApiData, Params extends JsonApiParams<Data> = JsonApiParams<Data>> {
    readonly config: JsonApiConfig;
    static readonly reqInitDefault: {
        headers: {
            "content-type": string;
        };
    };
    protected readonly reqInit: Defaulted<RequestInit, keyof typeof JsonApi["reqInitDefault"]>;
    static readonly configDefault: Partial<JsonApiConfig>;
    constructor(config: JsonApiConfig, reqInit?: RequestInit);
    readonly onData: EventEmitter<[Data, Response]>;
    readonly onError: EventEmitter<[JsonApiErrorParsed, Response]>;
    private readonly getRequestOptions;
    getResponse<Query>(path: string, params?: ParamsAndQuery<Params, Query>, init?: RequestInit): Promise<Response>;
    get<OutData = Data, Query = QueryParams>(path: string, params?: ParamsAndQuery<Params, Query>, reqInit?: RequestInit): Promise<OutData>;
    post<OutData = Data, Query = QueryParams>(path: string, params?: ParamsAndQuery<Params, Query>, reqInit?: RequestInit): Promise<OutData>;
    put<OutData = Data, Query = QueryParams>(path: string, params?: ParamsAndQuery<Params, Query>, reqInit?: RequestInit): Promise<OutData>;
    patch<OutData = Data, Query = QueryParams>(path: string, params?: (ParamsAndQuery<Omit<Params, "data">, Query> & {
        data?: Patch | PartialDeep<Data>;
    }), reqInit?: RequestInit): Promise<OutData>;
    del<OutData = Data, Query = QueryParams>(path: string, params?: ParamsAndQuery<Params, Query>, reqInit?: RequestInit): Promise<OutData>;
    protected request<OutData, Query = QueryParams>(path: string, params: (ParamsAndQuery<Omit<Params, "data">, Query> & {
        data?: unknown;
    }) | undefined, init: Defaulted<RequestInit, "method">): Promise<OutData>;
    protected parseResponse<OutData>(res: Response, log: JsonApiLog): Promise<OutData>;
    protected parseError(error: JsonApiError | string, res: Response): string[];
    protected writeLog(log: JsonApiLog): void;
}
export declare class JsonApiErrorParsed {
    private error;
    private messages;
    isUsedForNotification: boolean;
    constructor(error: JsonApiError | DOMException, messages: string[]);
    get isAborted(): boolean;
    toString(): string;
}
