/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { ClusterContext } from "./cluster-context";
import type { Disposer } from "../utils";
import type { KubeJsonApiDataFor, KubeObject } from "./kube-object";
import type { IKubeWatchEvent } from "./kube-watch-event";
import { ItemStore } from "../item.store";
import type { KubeApiQueryParams, KubeApi } from "./kube-api";
import type { RequestInit } from "node-fetch";
import AbortController from "abort-controller";
import type { Patch } from "rfc6902";
import type { PartialDeep } from "type-fest";
export declare type OnLoadFailure = (error: unknown) => void;
export interface KubeObjectStoreLoadingParams {
    namespaces: string[];
    reqInit?: RequestInit;
    /**
     * A function that is called when listing fails. If set then blocks errors
     * being rejected with
     */
    onLoadFailure?: OnLoadFailure;
}
export interface KubeObjectStoreLoadAllParams {
    namespaces?: string[];
    merge?: boolean;
    reqInit?: RequestInit;
    /**
     * A function that is called when listing fails. If set then blocks errors
     * being rejected with
     */
    onLoadFailure?: OnLoadFailure;
}
export interface KubeObjectStoreSubscribeParams {
    /**
     * A function that is called when listing fails. If set then blocks errors
     * being rejected with
     */
    onLoadFailure?: OnLoadFailure;
    /**
     * An optional parent abort controller
     */
    abortController?: AbortController;
}
export interface MergeItemsOptions {
    merge?: boolean;
    updateStore?: boolean;
    sort?: boolean;
    filter?: boolean;
    namespaces: string[];
}
export interface StatusProvider<K> {
    getStatuses(items: K[]): Record<string, number>;
}
export interface KubeObjectStoreOptions {
    limit?: number;
    bufferSize?: number;
}
export declare type KubeApiDataFrom<K extends KubeObject, A> = A extends KubeApi<K, infer D> ? D extends KubeJsonApiDataFor<K> ? D : never : never;
export declare type JsonPatch = Patch;
export declare abstract class KubeObjectStore<K extends KubeObject = KubeObject, A extends KubeApi<K, D> = KubeApi<K, KubeJsonApiDataFor<K>>, D extends KubeJsonApiDataFor<K> = KubeApiDataFrom<K, A>> extends ItemStore<K> {
    static readonly defaultContext: import("mobx").IObservableValue<ClusterContext | undefined>;
    readonly api: A;
    readonly limit: number | undefined;
    readonly bufferSize: number;
    private loadedNamespaces;
    get contextReady(): Promise<void> & {
        cancel(): void;
    };
    get namespacesReady(): Promise<void> & {
        cancel(): void;
    };
    constructor(api: A, opts?: KubeObjectStoreOptions);
    /**
     * @deprecated Supply API instance through constructor
     */
    constructor();
    get context(): ClusterContext | undefined;
    get contextItems(): K[];
    getTotalCount(): number;
    get query(): KubeApiQueryParams;
    getAllByNs(namespace: string | string[], strict?: boolean): K[];
    getById(id: string): K | undefined;
    getByName(name: string, namespace?: string): K | undefined;
    getByPath(path: string): K | undefined;
    getByLabel(labels: string[] | Partial<Record<string, string>>): K[];
    protected loadItems({ namespaces, reqInit, onLoadFailure }: KubeObjectStoreLoadingParams): Promise<K[]>;
    protected filterItemsOnLoad(items: K[]): K[];
    loadAll({ namespaces, merge, reqInit, onLoadFailure }?: KubeObjectStoreLoadAllParams): Promise<undefined | K[]>;
    reloadAll(opts?: {
        force?: boolean;
        namespaces?: string[];
        merge?: boolean;
    }): Promise<undefined | K[]>;
    protected mergeItems(partialItems: K[], { merge, updateStore, sort, filter, namespaces }: MergeItemsOptions): K[];
    protected resetOnError(error: any): void;
    protected loadItem(params: {
        name: string;
        namespace?: string;
    }): Promise<K | null>;
    load(params: {
        name: string;
        namespace?: string;
    }): Promise<K>;
    loadFromPath(resourcePath: string): Promise<K>;
    protected createItem(params: {
        name: string;
        namespace?: string;
    }, data?: PartialDeep<K>): Promise<K | null>;
    create(params: {
        name: string;
        namespace?: string;
    }, data?: PartialDeep<K>): Promise<K>;
    private postUpdate;
    patch(item: K, patch: JsonPatch): Promise<K>;
    update(item: K, data: PartialDeep<K>): Promise<K>;
    remove(item: K): Promise<void>;
    removeSelectedItems(): Promise<void>;
    removeItems(items: K[]): Promise<void>;
    protected eventsBuffer: import("mobx").IObservableArray<IKubeWatchEvent<D>>;
    protected bindWatchEventsUpdater(delay?: number): void;
    subscribe({ onLoadFailure, abortController }?: KubeObjectStoreSubscribeParams): Disposer;
    private watchNamespace;
    protected updateFromEventsBuffer(): void;
}
