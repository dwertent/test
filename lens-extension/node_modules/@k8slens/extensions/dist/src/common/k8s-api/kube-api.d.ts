/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
/// <reference types="node" />
import type { KubeObjectConstructor, KubeJsonApiDataFor, KubeObjectMetadata } from "./kube-object";
import { KubeObject } from "./kube-object";
import type { IKubeWatchEvent } from "./kube-watch-event";
import type { KubeJsonApiData } from "./kube-json-api";
import { KubeJsonApi } from "./kube-json-api";
import type { Disposer } from "../utils";
import type { RequestInit } from "node-fetch";
import type AbortController from "abort-controller";
import { Agent } from "https";
import type { Patch } from "rfc6902";
import type { PartialDeep } from "type-fest";
/**
 * The options used for creating a `KubeApi`
 */
export interface KubeApiOptions<T extends KubeObject, Data extends KubeJsonApiDataFor<T> = KubeJsonApiDataFor<T>> extends DerivedKubeApiOptions {
    /**
     * base api-path for listing all resources, e.g. "/api/v1/pods"
     *
     * Must be provided either here or under `objectConstructor.apiBase`
     * @deprecated should be specified by `objectConstructor`
     */
    apiBase?: string;
    /**
     * The constructor for the kube objects returned from the API
     */
    objectConstructor: KubeObjectConstructor<T, Data>;
    /**
     * Must be provided either here or under `objectConstructor.namespaced`
     * @deprecated should be specified by `objectConstructor`
     */
    isNamespaced?: boolean;
    /**
     * Must be provided either here or under `objectConstructor.kind`
     * @deprecated should be specified by `objectConstructor`
     */
    kind?: string;
}
export interface DerivedKubeApiOptions {
    /**
     * If the API uses a different API endpoint (e.g. apiBase) depending on the cluster version,
     * fallback API bases can be listed individually.
     * The first (existing) API base is used in the requests, if apiBase is not found.
     * This option only has effect if checkPreferredVersion is true.
     */
    fallbackApiBases?: string[];
    /**
     * If `true` then will check all declared apiBases against the kube api server
     * for the first accepted one.
     */
    checkPreferredVersion?: boolean;
    /**
     * The api instance to use for making requests
     *
     * @default apiKube
     */
    request?: KubeJsonApi;
}
/**
 * @deprecated This type is only present for backwards compatable typescript support
 */
export interface IgnoredKubeApiOptions {
    /**
     * @deprecated this option is overridden and should not be used
     */
    objectConstructor?: any;
    /**
     * @deprecated this option is overridden and should not be used
     */
    kind?: any;
    /**
     * @deprecated this option is overridden and should not be used
     */
    isNamespaces?: any;
    /**
     * @deprecated this option is overridden and should not be used
     */
    apiBase?: any;
}
export interface KubeApiQueryParams {
    watch?: boolean | number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    limit?: number;
    continue?: string;
    labelSelector?: string | string[];
    fieldSelector?: string | string[];
}
export interface KubeApiListOptions {
    namespace?: string;
    reqInit?: RequestInit;
}
export interface IKubePreferredVersion {
    preferredVersion?: {
        version: string;
    };
}
export interface KubeApiResource {
    categories?: string[];
    group?: string;
    kind: string;
    name: string;
    namespaced: boolean;
    shortNames?: string[];
    singularName: string;
    storageVersionHash?: string;
    verbs: string[];
    version?: string;
}
export interface KubeApiResourceList {
    apiVersion?: string;
    groupVersion?: string;
    kind?: string;
    resources: KubeApiResource[];
}
export interface ILocalKubeApiConfig {
    metadata: {
        uid: string;
    };
}
export declare type PropagationPolicy = undefined | "Orphan" | "Foreground" | "Background";
/**
 * @deprecated
 */
export interface IKubeApiCluster extends ILocalKubeApiConfig {
}
export interface IRemoteKubeApiConfig {
    cluster: {
        server: string;
        caData?: string;
        skipTLSVerify?: boolean;
    };
    user: {
        token?: string | (() => Promise<string>);
        clientCertificateData?: string;
        clientKeyData?: string;
    };
    /**
     * Custom instance of https.agent to use for the requests
     *
     * @remarks the custom agent replaced default agent, options skipTLSVerify,
     * clientCertificateData, clientKeyData and caData are ignored.
     */
    agent?: Agent;
}
export declare function forCluster<Object extends KubeObject, Api extends KubeApi<Object>, Data extends KubeJsonApiDataFor<Object>>(cluster: ILocalKubeApiConfig, kubeClass: KubeObjectConstructor<Object, Data>, apiClass: new (apiOpts: KubeApiOptions<Object>) => Api): Api;
export declare function forCluster<Object extends KubeObject, Data extends KubeJsonApiDataFor<Object>>(cluster: ILocalKubeApiConfig, kubeClass: KubeObjectConstructor<Object, Data>, apiClass?: new (apiOpts: KubeApiOptions<Object>) => KubeApi<Object>): KubeApi<Object>;
export declare function forRemoteCluster<Object extends KubeObject, Api extends KubeApi<Object>, Data extends KubeJsonApiDataFor<Object>>(config: IRemoteKubeApiConfig, kubeClass: KubeObjectConstructor<Object, Data>, apiClass: new (apiOpts: KubeApiOptions<Object>) => Api): Api;
export declare function forRemoteCluster<Object extends KubeObject, Data extends KubeJsonApiDataFor<Object>>(config: IRemoteKubeApiConfig, kubeClass: KubeObjectConstructor<Object, Data>, apiClass?: new (apiOpts: KubeApiOptions<Object>) => KubeApi<Object>): KubeApi<Object>;
export declare type KubeApiWatchCallback<T extends KubeJsonApiData = KubeJsonApiData> = (data: IKubeWatchEvent<T>, error: any) => void;
export interface KubeApiWatchOptions<Object extends KubeObject, Data extends KubeJsonApiDataFor<Object>> {
    namespace: string;
    callback?: KubeApiWatchCallback<Data>;
    abortController?: AbortController;
    watchId?: string;
    retry?: boolean;
    timeout?: number;
}
export declare type KubeApiPatchType = "merge" | "json" | "strategic";
export interface ResourceDescriptor {
    /**
     * The name of the kubernetes resource
     */
    name: string;
    /**
     * The namespace that the resource lives in (if the resource is namespaced)
     *
     * Note: if not provided and the resource kind is namespaced, then this defaults to `"default"`
     */
    namespace?: string;
}
export interface DeleteResourceDescriptor extends ResourceDescriptor {
    /**
     * This determinines how child resources should be handled by kubernetes
     *
     * @default "Background"
     */
    propagationPolicy?: PropagationPolicy;
}
export declare class KubeApi<Object extends KubeObject = KubeObject, Data extends KubeJsonApiDataFor<Object> = KubeJsonApiDataFor<Object>> {
    readonly kind: string;
    readonly apiVersion: string;
    apiBase: string;
    apiPrefix: string;
    apiGroup: string;
    apiVersionPreferred: string | undefined;
    readonly apiResource: string;
    readonly isNamespaced: boolean;
    readonly objectConstructor: KubeObjectConstructor<Object, Data>;
    protected readonly request: KubeJsonApi;
    protected readonly resourceVersions: Map<string, string>;
    protected readonly watchDisposer: Disposer | undefined;
    private watchId;
    protected readonly doCheckPreferredVersion: boolean;
    protected readonly fullApiPathname: string;
    protected readonly fallbackApiBases: string[] | undefined;
    constructor(opts: KubeApiOptions<Object, Data>);
    get apiVersionWithGroup(): string;
    /**
     * Returns the latest API prefix/group that contains the required resource.
     * First tries fullApiPathname, then urls in order from fallbackApiBases.
     */
    private getLatestApiPrefixGroup;
    /**
     * Get the apiPrefix and apiGroup to be used for fetching the preferred version.
     */
    private getPreferredVersionPrefixGroup;
    protected checkPreferredVersion(): Promise<void>;
    setResourceVersion(namespace: string | undefined, newVersion: string): void;
    getResourceVersion(namespace?: string): string | undefined;
    refreshResourceVersion(params?: KubeApiListOptions): Promise<Object[] | null>;
    private computeApiBase;
    getUrl({ name, namespace }?: Partial<ResourceDescriptor>, query?: Partial<KubeApiQueryParams>): string;
    protected normalizeQuery(query?: Partial<KubeApiQueryParams>): Partial<KubeApiQueryParams>;
    protected parseResponse(data: unknown, namespace?: string): Object | Object[] | null;
    private ensureMetadataSelfLink;
    list({ namespace, reqInit }?: KubeApiListOptions, query?: KubeApiQueryParams): Promise<Object[] | null>;
    get(desc: ResourceDescriptor, query?: KubeApiQueryParams): Promise<Object | null>;
    create({ name, namespace }: Partial<ResourceDescriptor>, partialData?: PartialDeep<Object>): Promise<Object | null>;
    update({ name, namespace }: ResourceDescriptor, data: PartialDeep<Object>): Promise<Object | null>;
    patch(desc: ResourceDescriptor, data: PartialDeep<Object> | Patch, strategy?: KubeApiPatchType): Promise<Object | null>;
    delete({ propagationPolicy, ...desc }: DeleteResourceDescriptor): Promise<KubeJsonApiData<import("./kube-object").KubeJsonApiObjectMetadata<import("./kube-object").KubeObjectScope>, unknown, unknown>>;
    getWatchUrl(namespace?: string, query?: KubeApiQueryParams): string;
    watch(opts?: KubeApiWatchOptions<Object, Data>): () => void;
    protected modifyWatchEvent(event: IKubeWatchEvent<KubeJsonApiData<KubeObjectMetadata>>): void;
}
