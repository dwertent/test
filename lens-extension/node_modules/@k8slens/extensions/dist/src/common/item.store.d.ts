/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
export interface ItemObject {
    getId(): string;
    getName(): string;
}
export declare abstract class ItemStore<Item extends ItemObject> {
    protected defaultSorting: (item: Item) => string;
    failedLoading: boolean;
    isLoading: boolean;
    isLoaded: boolean;
    items: import("mobx").IObservableArray<Item>;
    selectedItemsIds: import("mobx").ObservableSet<string>;
    constructor();
    get selectedItems(): Item[];
    pickOnlySelected(items: Item[]): Item[];
    getItems(): Item[];
    getTotalCount(): number;
    getByName(name: string): Item | undefined;
    getIndexById(id: string): number;
    /**
     * Return `items` sorted by the given ordering functions. If two elements of
     * `items` are sorted to the same "index" then the next sorting function is used
     * to determine where to place them relative to each other. Once the `sorting`
     * functions have been all exhausted then the order is unchanged (ie a stable sort).
     * @param items the items to be sorted (default: the current items in this store)
     * @param sorting list of functions to determine sort order (default: sorting by name)
     * @param order whether to sort from least to greatest (`"asc"` (default)) or vice-versa (`"desc"`)
     */
    protected sortItems(items?: Item[], sorting?: ((item: Item) => any)[], order?: "asc" | "desc"): Item[];
    protected createItem(...args: any[]): Promise<any>;
    protected loadItems(...args: any[]): Promise<any>;
    protected loadItem(request: () => Promise<Item>, sortItems?: boolean): Promise<Item | null>;
    protected updateItem(item: Item, request: () => Promise<Item>): Promise<Item>;
    protected removeItem(item: Item, request: () => Promise<any>): Promise<void>;
    isSelected(item: Item): boolean;
    select(item: Item): void;
    unselect(item: Item): void;
    toggleSelection(item: Item): void;
    toggleSelectionAll(visibleItems?: Item[]): void;
    isSelectedAll(visibleItems?: Item[]): boolean;
    resetSelection(): void;
    reset(): void;
    removeSelectedItems?(): Promise<any>;
    removeItems?(items: Item[]): Promise<void>;
    [Symbol.iterator](): Generator<Item, void, undefined>;
}
