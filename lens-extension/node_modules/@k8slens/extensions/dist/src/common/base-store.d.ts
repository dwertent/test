/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type Config from "conf";
import type { Options as ConfOptions } from "conf/dist/source/types";
import type { IEqualsComparer } from "mobx";
import type { Disposer } from "./utils";
import { Singleton } from "./utils";
export interface BaseStoreParams<T> extends ConfOptions<T> {
    syncOptions?: {
        fireImmediately?: boolean;
        equals?: IEqualsComparer<T>;
    };
}
/**
 * Note: T should only contain base JSON serializable types.
 */
export declare abstract class BaseStore<T> extends Singleton {
    protected params: BaseStoreParams<T>;
    protected storeConfig?: Config<T>;
    protected syncDisposers: Disposer[];
    readonly displayName: string;
    protected constructor(params: BaseStoreParams<T>);
    /**
     * This must be called after the last child's constructor is finished (or just before it finishes)
     */
    load(): void;
    get name(): string;
    protected get syncRendererChannel(): string;
    protected get syncMainChannel(): string;
    get path(): string;
    protected cwd(): string;
    protected saveToFile(model: T): void;
    enableSync(): void;
    protected onSyncFromMain(model: T): void;
    unregisterIpcListener(): void;
    disableSync(): void;
    protected applyWithoutSync(callback: () => void): void;
    protected onSync(model: T): void;
    protected onModelChange(model: T): void;
    /**
     * fromStore is called internally when a child class syncs with the file
     * system.
     *
     * Note: This function **must** be synchronous.
     *
     * @param data the parsed information read from the stored JSON file
     */
    protected abstract fromStore(data: T): void;
    /**
     * toJSON is called when syncing the store to the filesystem. It should
     * produce a JSON serializable object representation of the current state.
     *
     * It is recommended that a round trip is valid. Namely, calling
     * `this.fromStore(this.toJSON())` shouldn't change the state.
     */
    abstract toJSON(): T;
}
