/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import { ItemStore } from "../../../common/item.store";
import type { StorageLayer } from "../../utils";
import type { ForwardedPort } from "../port-forward-item";
import { PortForwardItem } from "../port-forward-item";
interface Dependencies {
    storage: StorageLayer<ForwardedPort[] | undefined>;
    notifyErrorPortForwarding: (message: string) => void;
}
export declare class PortForwardStore extends ItemStore<PortForwardItem> {
    private dependencies;
    portForwards: PortForwardItem[];
    constructor(dependencies: Dependencies);
    private init;
    watch(): import("../../utils").ExtendableDisposer;
    loadAll(): Promise<any>;
    removeItems(items: PortForwardItem[]): Promise<void>;
    getById(id: string): PortForwardItem | undefined;
    /**
     * add a port-forward to the store and optionally start it
     * @param portForward the port-forward to add. If the port-forward already exists in the store it will be
     * returned with its current state. If the forwardPort field is 0 then an arbitrary port will be
     * used. If the status field is "Active" or not present then an attempt is made to start the port-forward.
     *
     * @returns the port-forward with updated status ("Active" if successfully started, "Disabled" otherwise) and
     * forwardPort
     */
    add: (portForward: ForwardedPort) => Promise<ForwardedPort>;
    /**
     * modifies a port-forward in the store, including the forwardPort and protocol
     * @param portForward the port-forward to modify.
     *
     * @returns the port-forward after being modified.
     */
    modify: (portForward: ForwardedPort, desiredPort: number) => Promise<ForwardedPort>;
    /**
     * remove and stop an existing port-forward.
     * @param portForward the port-forward to remove.
     */
    remove: (portForward: ForwardedPort) => Promise<void>;
    /**
     * gets the list of port-forwards in the store
     *
     * @returns the port-forwards
     */
    getPortForwards: () => ForwardedPort[];
    /**
     * stop an existing port-forward. Its status is set to "Disabled" after successfully stopped.
     * @param portForward the port-forward to stop.
     *
     * @throws if the port-forward could not be stopped. Its status is unchanged
     */
    stop: (portForward: ForwardedPort) => Promise<void>;
    private findPortForward;
    private setPortForward;
    /**
     * start an existing port-forward
     * @param portForward the port-forward to start. If the forwardPort field is 0 then an arbitrary port will be
     * used
     *
     * @returns the port-forward with updated status ("Active" if successfully started, "Disabled" otherwise) and
     * forwardPort
     *
     * @throws if the port-forward does not already exist in the store
     */
    start: (portForward: ForwardedPort) => Promise<ForwardedPort>;
    /**
     * get a port-forward from the store, with up-to-date status
     * @param portForward the port-forward to get.
     *
     * @returns the port-forward with updated status ("Active" if running, "Disabled" if not) and
     * forwardPort used.
     *
     * @throws if the port-forward does not exist in the store
     */
    getPortForward: (portForward: ForwardedPort) => Promise<ForwardedPort | undefined>;
}
export {};
