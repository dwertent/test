/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
/// <reference types="lodash" />
import "./input.scss";
import type { DOMAttributes, InputHTMLAttributes, TextareaHTMLAttributes } from "react";
import React from "react";
import type { TooltipProps } from "../tooltip";
import * as Validators from "./input_validators";
import type { InputValidator, InputValidation, InputValidationResult, SyncValidationMessage } from "./input_validators";
declare const asyncInputValidator: typeof Validators.asyncInputValidator, inputValidator: typeof Validators.inputValidator, isAsyncValidator: typeof Validators.isAsyncValidator, unionInputValidatorsAsync: typeof Validators.unionInputValidatorsAsync, InputValidators: {
    unionInputValidators(baseValidator: Pick<Validators.SyncInputValidator, "message" | "condition">, ...validators: Validators.SyncInputValidator[]): Validators.SyncInputValidator;
    isRequired: Validators.SyncInputValidator;
    isEmail: Validators.SyncInputValidator;
    isNumber: Validators.SyncInputValidator;
    isUrl: Validators.SyncInputValidator;
    isExtensionNameInstallRegex: {
        isMatch(val: string): boolean;
        captures(val: string): {
            name: string;
            version?: string | undefined;
        } | undefined;
    };
    isExtensionNameInstall: Validators.SyncInputValidator;
    isPath: Validators.AsyncInputValidator;
    minLength: Validators.SyncInputValidator;
    maxLength: Validators.SyncInputValidator;
    systemName: Validators.SyncInputValidator;
    accountId: Validators.SyncInputValidator;
};
export { InputValidators, asyncInputValidator, inputValidator, isAsyncValidator, unionInputValidatorsAsync, };
export type { InputValidator, InputValidation, InputValidationResult, SyncValidationMessage, };
declare type InputElement = HTMLInputElement | HTMLTextAreaElement;
declare type InputElementProps = InputHTMLAttributes<HTMLInputElement> & TextareaHTMLAttributes<HTMLTextAreaElement> & DOMAttributes<InputElement>;
export interface IconDataFnArg {
    isDirty: boolean;
}
/**
 * One of the folloing:
 * - A material icon name
 * - A react node
 * - Or a function that produces a react node
 */
export declare type IconData = string | React.ReactNode | ((opt: IconDataFnArg) => React.ReactNode);
export declare type InputProps = Omit<InputElementProps, "onChange" | "onSubmit"> & {
    theme?: "round-black" | "round";
    className?: string;
    value?: string;
    trim?: boolean;
    autoSelectOnFocus?: boolean;
    defaultValue?: string;
    multiLine?: boolean;
    maxRows?: number;
    dirty?: boolean;
    showValidationLine?: boolean;
    showErrorsAsTooltip?: boolean | Omit<TooltipProps, "targetId">;
    iconLeft?: IconData;
    iconRight?: IconData;
    contentRight?: string | React.ReactNode;
    validators?: InputValidator<boolean> | InputValidator<boolean>[];
    blurOnEnter?: boolean;
    onChange?(value: string, evt: React.ChangeEvent<InputElement>): void;
    onSubmit?(value: string, evt: React.KeyboardEvent<InputElement>): void;
};
interface State {
    focused: boolean;
    dirty: boolean;
    valid: boolean;
    validating: boolean;
    errors: React.ReactNode[];
    submitted: boolean;
}
export declare class Input extends React.Component<InputProps, State> {
    static defaultProps: object;
    input: InputElement | null;
    validators: InputValidator[];
    state: State;
    constructor(props: InputProps);
    componentWillUnmount(): void;
    setValue(value?: string): void;
    getValue(): string;
    focus(): void;
    blur(): void;
    select(): void;
    private autoFitHeight;
    private validationId?;
    validate(): Promise<void>;
    setValidation(errors: React.ReactNode[]): void;
    private getValidatorError;
    private setupValidators;
    setDirty(dirty?: boolean): void;
    onFocus(evt: React.FocusEvent<InputElement>): void;
    onBlur(evt: React.FocusEvent<InputElement>): void;
    setDirtyOnChange: import("lodash").DebouncedFunc<() => void>;
    onChange(evt: React.ChangeEvent<any>): Promise<void>;
    onKeyDown(evt: React.KeyboardEvent<InputElement>): void;
    get showMaxLenIndicator(): boolean | 0 | undefined;
    get isUncontrolled(): boolean;
    componentDidMount(): void;
    componentDidUpdate(prevProps: InputProps): void;
    get themeSelection(): Record<string, boolean>;
    bindRef(elem: InputElement): void;
    private renderIcon;
    render(): JSX.Element;
}
