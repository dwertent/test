/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type { CatalogCategory, CatalogEntity, CatalogEntityData, CatalogCategoryRegistry, CatalogEntityKindData } from "../../../../common/catalog";
import "../../../../common/catalog-entities";
import type { Disposer } from "../../../utils";
import { CatalogRunEvent } from "../../../../common/catalog/catalog-run-event";
import type { Navigate } from "../../../navigation/navigate.injectable";
export declare type EntityFilter = (entity: CatalogEntity) => any;
export declare type CatalogEntityOnBeforeRun = (event: CatalogRunEvent) => void | Promise<void>;
interface Dependencies {
    navigate: Navigate;
    readonly categoryRegistry: CatalogCategoryRegistry;
}
export declare class CatalogEntityRegistry {
    protected readonly dependencies: Dependencies;
    protected readonly activeEntityId: import("mobx").IObservableValue<string | undefined>;
    protected readonly _entities: import("mobx").ObservableMap<string, CatalogEntity<import("../../../../common/catalog").CatalogEntityMetadata, import("../../../../common/catalog").CatalogEntityStatus, import("../../../../common/catalog").CatalogEntitySpec>>;
    protected readonly filters: import("mobx").ObservableSet<EntityFilter>;
    protected readonly onBeforeRunHooks: import("mobx").ObservableSet<CatalogEntityOnBeforeRun>;
    /**
     * Buffer for keeping entities that don't yet have CatalogCategory synced
     */
    protected readonly rawEntities: (CatalogEntityData & CatalogEntityKindData)[];
    constructor(dependencies: Dependencies);
    protected getActiveEntityById(): CatalogEntity<import("../../../../common/catalog").CatalogEntityMetadata, import("../../../../common/catalog").CatalogEntityStatus, import("../../../../common/catalog").CatalogEntitySpec> | undefined;
    get activeEntity(): CatalogEntity | undefined;
    set activeEntity(raw: CatalogEntity | string | undefined);
    init(): void;
    updateItems(items: (CatalogEntityData & CatalogEntityKindData)[]): void;
    protected updateItem(item: (CatalogEntityData & CatalogEntityKindData)): void;
    protected processRawEntities(): void;
    readonly items: import("mobx").IComputedValue<CatalogEntity<import("../../../../common/catalog").CatalogEntityMetadata, import("../../../../common/catalog").CatalogEntityStatus, import("../../../../common/catalog").CatalogEntitySpec>[]>;
    get filteredItems(): CatalogEntity<import("../../../../common/catalog").CatalogEntityMetadata, import("../../../../common/catalog").CatalogEntityStatus, import("../../../../common/catalog").CatalogEntitySpec>[];
    get entities(): Map<string, CatalogEntity>;
    get filteredEntities(): Map<string, CatalogEntity>;
    getById(id: string): CatalogEntity<import("../../../../common/catalog").CatalogEntityMetadata, import("../../../../common/catalog").CatalogEntityStatus, import("../../../../common/catalog").CatalogEntitySpec> | undefined;
    getItemsForApiKind<T extends CatalogEntity>(apiVersion: string, kind: string, { filtered }?: {
        filtered?: boolean | undefined;
    }): T[];
    getItemsForCategory<T extends CatalogEntity>(category: CatalogCategory, { filtered }?: {
        filtered?: boolean | undefined;
    }): T[];
    /**
     * Add a new filter to the set of item filters
     * @param fn The function that should return a truthy value if that entity should be sent currently "active"
     * @returns A function to remove that filter
     */
    addCatalogFilter(fn: EntityFilter): Disposer;
    /**
     * Add a onBeforeRun hook. If `onBeforeRun` was previously added then it will not be added again
     * @param onBeforeRun The function that should return a boolean if the onRun of catalog entity should be triggered.
     * @returns A function to remove that hook
     */
    addOnBeforeRun(onBeforeRun: CatalogEntityOnBeforeRun): Disposer;
    /**
     * Runs all the registered `onBeforeRun` hooks, short circuiting on the first event that's preventDefaulted
     * @param entity The entity to run the hooks on
     * @returns Whether the entities `onRun` method should be executed
     */
    onBeforeRun(entity: CatalogEntity): Promise<boolean>;
    /**
     * Perform the onBeforeRun check and, if successful, then proceed to call `entity`'s onRun method
     * @param entity The instance to invoke the hooks and then execute the onRun
     */
    onRun(entity: CatalogEntity): void;
}
export {};
