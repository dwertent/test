/**
 * Copyright (c) OpenLens Authors. All rights reserved.
 * Licensed under MIT License. See LICENSE in root directory for more information.
 */
import type TypedEventEmitter from "typed-emitter";
import type { Defaulted } from "../utils";
interface WebsocketApiParams {
    /**
     * Flush pending commands on open socket
     *
     * @default true
     */
    flushOnOpen?: boolean;
    /**
     * In case of an error, wait this many seconds before reconnecting.
     *
     * If falsy, don't reconnect
     *
     * @default 10
     */
    reconnectDelay?: number;
    /**
     * The message for pinging the websocket
     *
     * @default "{type: \"ping\"}"
     */
    pingMessage?: string;
    /**
     * If set to a number > 0, then the API will ping the socket on that interval.
     *
     * @unit seconds
     */
    pingInterval?: number;
    /**
     * Whether to show logs in the console
     *
     * @default isDevelopment
     */
    logging?: boolean;
}
export declare enum WebSocketApiState {
    PENDING = "pending",
    OPEN = "open",
    CONNECTING = "connecting",
    RECONNECTING = "reconnecting",
    CLOSED = "closed"
}
export interface WebSocketEvents {
    open: () => void;
    data: (message: string) => void;
    close: () => void;
}
declare const WebSocketApi_base: new <T>() => TypedEventEmitter<T>;
export declare class WebSocketApi<Events extends WebSocketEvents> extends WebSocketApi_base<Events> {
    protected socket: WebSocket | null;
    protected pendingCommands: string[];
    protected reconnectTimer?: number;
    protected pingTimer?: number;
    protected params: Defaulted<WebsocketApiParams, keyof typeof WebSocketApi["defaultParams"]>;
    readyState: WebSocketApiState;
    private static readonly defaultParams;
    constructor(params: WebsocketApiParams);
    isConnected(): this is (WebSocketApi<Events> & {
        socket: WebSocket;
    });
    connect(url: string): void;
    ping(): void;
    reconnect(): void;
    destroy(): void;
    clearAllListeners(): void;
    send(command: string): void;
    protected flush(): void;
    protected _onOpen(evt: Event): void;
    protected _onMessage({ data }: MessageEvent): void;
    protected _onError(evt: Event): void;
    protected _onClose(evt: CloseEvent): void;
    protected writeLog(...data: any[]): void;
}
export {};
